// Code generated by pqt.
// source: cmd/appg/main.go
// DO NOT EDIT!
package model

import (
	"bytes"
	"context"
	"database/sql"
	"database/sql/driver"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strconv"
	"strings"
	"time"

	"github.com/lib/pq"
)

// LogFunc represents function that can be passed into repository to log query result.
type LogFunc func(err error, ent, fnc, sql string, args ...interface{})

// Rows ...
type Rows interface {
	io.Closer
	ColumnTypes() ([]*sql.ColumnType, error)
	Columns() ([]string, error)
	Err() error
	Next() bool
	NextResultSet() bool
	Scan(dst ...interface{}) error
}

func joinClause(comp *Composer, jt JoinType, on string) (ok bool, err error) {
	if jt != JoinDoNot {
		switch jt {
		case JoinInner:
			if _, err = comp.WriteString(" INNER JOIN "); err != nil {
				return
			}
		case JoinLeft:
			if _, err = comp.WriteString(" LEFT JOIN "); err != nil {
				return
			}
		case JoinRight:
			if _, err = comp.WriteString(" RIGHT JOIN "); err != nil {
				return
			}
		case JoinCross:
			if _, err = comp.WriteString(" CROSS JOIN "); err != nil {
				return
			}
		default:
			return
		}
		if _, err = comp.WriteString(on); err != nil {
			return
		}
		comp.Dirty = true
		ok = true
		return
	}
	return
}

const (
	TableCategoryConstraintPrimaryKey         = "example.category_id_pkey"
	TableCategoryConstraintParentIDForeignKey = "example.category_parent_id_fkey"
	TableCategoryConstraintNameIndex          = "example.category_name_idx"
)

const (
	TableCategory                = "example.category"
	TableCategoryColumnContent   = "content"
	TableCategoryColumnCreatedAt = "created_at"
	TableCategoryColumnID        = "id"
	TableCategoryColumnName      = "name"
	TableCategoryColumnParentID  = "parent_id"
	TableCategoryColumnUpdatedAt = "updated_at"
)

var TableCategoryColumns = []string{
	TableCategoryColumnContent,
	TableCategoryColumnCreatedAt,
	TableCategoryColumnID,
	TableCategoryColumnName,
	TableCategoryColumnParentID,
	TableCategoryColumnUpdatedAt,
}

// CategoryEntity ...
type CategoryEntity struct {
	// Content ...
	Content string
	// CreatedAt ...
	CreatedAt time.Time
	// ID ...
	ID int64
	// Name ...
	Name string
	// ParentID ...
	ParentID sql.NullInt64
	// UpdatedAt ...
	UpdatedAt pq.NullTime
	// ChildCategory ...
	ChildCategory []*CategoryEntity
	// ParentCategory ...
	ParentCategory *CategoryEntity
	// Packages ...
	Packages []*PackageEntity
}

func (e *CategoryEntity) Prop(cn string) (interface{}, bool) {
	switch cn {

	case TableCategoryColumnContent:
		return &e.Content, true
	case TableCategoryColumnCreatedAt:
		return &e.CreatedAt, true
	case TableCategoryColumnID:
		return &e.ID, true
	case TableCategoryColumnName:
		return &e.Name, true
	case TableCategoryColumnParentID:
		return &e.ParentID, true
	case TableCategoryColumnUpdatedAt:
		return &e.UpdatedAt, true
	default:
		return nil, false
	}
}

func (e *CategoryEntity) Props(cns ...string) ([]interface{}, error) {
	if len(cns) == 0 {
		cns = TableCategoryColumns
	}
	res := make([]interface{}, 0, len(cns))
	for _, cn := range cns {
		if prop, ok := e.Prop(cn); ok {
			res = append(res, prop)
		} else {
			return nil, fmt.Errorf("unexpected column provided: %s", cn)
		}
	}
	return res, nil
}

// ScanCategoryRows helps to scan rows straight to the slice of entities.
func ScanCategoryRows(rows Rows) (entities []*CategoryEntity, err error) {
	for rows.Next() {
		var ent CategoryEntity
		err = rows.Scan(
			&ent.Content,
			&ent.CreatedAt,
			&ent.ID,
			&ent.Name,
			&ent.ParentID,
			&ent.UpdatedAt,
		)
		if err != nil {
			return
		}

		entities = append(entities, &ent)
	}
	if err = rows.Err(); err != nil {
		return
	}

	return
}

// CategoryIterator is not thread safe.
type CategoryIterator struct {
	rows Rows
	cols []string
	expr *CategoryFindExpr
}

func (i *CategoryIterator) Next() bool {
	return i.rows.Next()
}

func (i *CategoryIterator) Close() error {
	return i.rows.Close()
}

func (i *CategoryIterator) Err() error {
	return i.rows.Err()
}

// Columns is wrapper around sql.Rows.Columns method, that also cache output inside iterator.
func (i *CategoryIterator) Columns() ([]string, error) {
	if i.cols == nil {
		cols, err := i.rows.Columns()
		if err != nil {
			return nil, err
		}
		i.cols = cols
	}
	return i.cols, nil
}

// Ent is wrapper around Category method that makes iterator more generic.
func (i *CategoryIterator) Ent() (interface{}, error) {
	return i.Category()
}

func (i *CategoryIterator) Category() (*CategoryEntity, error) {
	var ent CategoryEntity
	cols, err := i.Columns()
	if err != nil {
		return nil, err
	}

	props, err := ent.Props(cols...)
	if err != nil {
		return nil, err
	}
	if err := i.rows.Scan(props...); err != nil {
		return nil, err
	}
	return &ent, nil
}

type CategoryCriteria struct {
	Content                sql.NullString
	CreatedAt              pq.NullTime
	ID                     sql.NullInt64
	Name                   sql.NullString
	ParentID               sql.NullInt64
	UpdatedAt              pq.NullTime
	operator               string
	child, sibling, parent *CategoryCriteria
}

func CategoryOperand(operator string, operands ...*CategoryCriteria) *CategoryCriteria {
	if len(operands) == 0 {
		return &CategoryCriteria{operator: operator}
	}

	parent := &CategoryCriteria{
		operator: operator,
		child:    operands[0],
	}

	for i := 0; i < len(operands); i++ {
		if i < len(operands)-1 {
			operands[i].sibling = operands[i+1]
		}
		operands[i].parent = parent
	}

	return parent
}

func CategoryOr(operands ...*CategoryCriteria) *CategoryCriteria {
	return CategoryOperand("OR", operands...)
}

func CategoryAnd(operands ...*CategoryCriteria) *CategoryCriteria {
	return CategoryOperand("AND", operands...)
}

type CategoryFindExpr struct {
	Where         *CategoryCriteria
	Offset, Limit int64
	Columns       []string
	OrderBy       []RowOrder
}

type CategoryJoin struct {
	On, Where *CategoryCriteria
	Fetch     bool
	Kind      JoinType
}

type CategoryCountExpr struct {
	Where *CategoryCriteria
}

type CategoryPatch struct {
	Content   sql.NullString
	CreatedAt pq.NullTime
	Name      sql.NullString
	ParentID  sql.NullInt64
	UpdatedAt pq.NullTime
}

type CategoryRepositoryBase struct {
	Table   string
	Columns []string
	DB      *sql.DB
	Log     LogFunc
}

func (r *CategoryRepositoryBase) InsertQuery(e *CategoryEntity, read bool) (string, []interface{}, error) {
	insert := NewComposer(6)
	columns := bytes.NewBuffer(nil)
	buf := bytes.NewBufferString("INSERT INTO ")
	buf.WriteString(r.Table)

	if columns.Len() > 0 {
		if _, err := columns.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if _, err := columns.WriteString(TableCategoryColumnContent); err != nil {
		return "", nil, err
	}
	if insert.Dirty {
		if _, err := insert.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if err := insert.WritePlaceholder(); err != nil {
		return "", nil, err
	}
	insert.Add(e.Content)
	insert.Dirty = true

	if !e.CreatedAt.IsZero() {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCategoryColumnCreatedAt); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.CreatedAt)
		insert.Dirty = true
	}

	if columns.Len() > 0 {
		if _, err := columns.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if _, err := columns.WriteString(TableCategoryColumnName); err != nil {
		return "", nil, err
	}
	if insert.Dirty {
		if _, err := insert.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if err := insert.WritePlaceholder(); err != nil {
		return "", nil, err
	}
	insert.Add(e.Name)
	insert.Dirty = true

	if e.ParentID.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCategoryColumnParentID); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ParentID)
		insert.Dirty = true
	}

	if e.UpdatedAt.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCategoryColumnUpdatedAt); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.UpdatedAt)
		insert.Dirty = true
	}

	if columns.Len() > 0 {
		buf.WriteString(" (")
		buf.ReadFrom(columns)
		buf.WriteString(") VALUES (")
		buf.ReadFrom(insert)
		buf.WriteString(") ")
		if read {
			buf.WriteString("RETURNING ")
			if len(r.Columns) > 0 {
				buf.WriteString(strings.Join(r.Columns, ", "))
			} else {
				buf.WriteString("content, created_at, id, name, parent_id, updated_at")
			}
		}
	}
	return buf.String(), insert.Args(), nil
}

func (r *CategoryRepositoryBase) Insert(ctx context.Context, e *CategoryEntity) (*CategoryEntity, error) {
	query, args, err := r.InsertQuery(e, true)
	if err != nil {
		return nil, err
	}
	err = r.DB.QueryRowContext(ctx, query, args...).Scan(
		&e.Content,
		&e.CreatedAt,
		&e.ID,
		&e.Name,
		&e.ParentID,
		&e.UpdatedAt,
	)
	if r.Log != nil {
		r.Log(err, TableCategory, "insert", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return e, nil
}

func CategoryCriteriaWhereClause(comp *Composer, c *CategoryCriteria, id int) error {
	if c.child == nil {
		return _CategoryCriteriaWhereClause(comp, c, id)
	}
	node := c
	sibling := false
	for {
		if !sibling {
			if node.child != nil {
				if node.parent != nil {
					comp.WriteString("(")
				}
				node = node.child
				continue
			} else {
				comp.Dirty = false
				comp.WriteString("(")
				if err := _CategoryCriteriaWhereClause(comp, node, id); err != nil {
					return err
				}
				comp.WriteString(")")
			}
		}
		if node.sibling != nil {
			sibling = false
			comp.WriteString(" ")
			comp.WriteString(node.parent.operator)
			comp.WriteString(" ")
			node = node.sibling
			continue
		}
		if node.parent != nil {
			sibling = true
			if node.parent.parent != nil {
				comp.WriteString(")")
			}
			node = node.parent
			continue
		}

		break
	}
	return nil
}

func _CategoryCriteriaWhereClause(comp *Composer, c *CategoryCriteria, id int) error {
	if c.Content.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCategoryColumnContent); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.Content)
		comp.Dirty = true
	}
	if c.CreatedAt.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCategoryColumnCreatedAt); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.CreatedAt)
		comp.Dirty = true
	}
	// id is an empty struct, ignore

	if c.Name.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCategoryColumnName); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.Name)
		comp.Dirty = true
	}
	if c.ParentID.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCategoryColumnParentID); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ParentID)
		comp.Dirty = true
	}
	if c.UpdatedAt.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCategoryColumnUpdatedAt); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.UpdatedAt)
		comp.Dirty = true
	}
	return nil
}

func (r *CategoryRepositoryBase) FindQuery(fe *CategoryFindExpr) (string, []interface{}, error) {
	comp := NewComposer(6)
	buf := bytes.NewBufferString("SELECT ")
	if len(fe.Columns) == 0 {
		buf.WriteString("t0.content, t0.created_at, t0.id, t0.name, t0.parent_id, t0.updated_at")
	} else {
		buf.WriteString(strings.Join(fe.Columns, ", "))
	}
	buf.WriteString(" FROM ")
	buf.WriteString(r.Table)
	buf.WriteString(" AS t0")
	if comp.Dirty {
		buf.ReadFrom(comp)
		comp.Dirty = false
	}
	if fe.Where != nil {
		if err := CategoryCriteriaWhereClause(comp, fe.Where, 0); err != nil {
			return "", nil, err
		}
	}
	if comp.Dirty {
		if _, err := buf.WriteString(" WHERE "); err != nil {
			return "", nil, err
		}
		buf.ReadFrom(comp)
	}

	if len(fe.OrderBy) > 0 {
		i := 0
		for _, order := range fe.OrderBy {
			for _, columnName := range TableCategoryColumns {
				if order.Name == columnName {
					if i == 0 {
						comp.WriteString(" ORDER BY ")
					}
					if i > 0 {
						if _, err := comp.WriteString(", "); err != nil {
							return "", nil, err
						}
					}
					if _, err := comp.WriteString(order.Name); err != nil {
						return "", nil, err
					}
					if order.Descending {
						if _, err := comp.WriteString(" DESC"); err != nil {
							return "", nil, err
						}
					}
					i++
					break
				}
			}
		}
	}
	if fe.Offset > 0 {
		if _, err := comp.WriteString(" OFFSET "); err != nil {
			return "", nil, err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		if _, err := comp.WriteString(" "); err != nil {
			return "", nil, err
		}
		comp.Add(fe.Offset)
	}
	if fe.Limit > 0 {
		if _, err := comp.WriteString(" LIMIT "); err != nil {
			return "", nil, err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		if _, err := comp.WriteString(" "); err != nil {
			return "", nil, err
		}
		comp.Add(fe.Limit)
	}

	buf.ReadFrom(comp)

	return buf.String(), comp.Args(), nil
}

func (r *CategoryRepositoryBase) Find(ctx context.Context, fe *CategoryFindExpr) ([]*CategoryEntity, error) {
	query, args, err := r.FindQuery(fe)
	if err != nil {
		return nil, err
	}
	rows, err := r.DB.QueryContext(ctx, query, args...)
	if r.Log != nil {
		r.Log(err, TableCategory, "find", query, args...)
	}
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var (
		entities []*CategoryEntity
		props    []interface{}
	)
	for rows.Next() {
		var ent CategoryEntity
		if props, err = ent.Props(); err != nil {
			return nil, err
		}
		err = rows.Scan(props...)
		if err != nil {
			return nil, err
		}

		entities = append(entities, &ent)
	}
	err = rows.Err()
	if r.Log != nil {
		r.Log(err, TableCategory, "find", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return entities, nil
}

func (r *CategoryRepositoryBase) FindIter(ctx context.Context, fe *CategoryFindExpr) (*CategoryIterator, error) {
	query, args, err := r.FindQuery(fe)
	if err != nil {
		return nil, err
	}
	rows, err := r.DB.QueryContext(ctx, query, args...)
	if r.Log != nil {
		r.Log(err, TableCategory, "find iter", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return &CategoryIterator{
		rows: rows,
		expr: fe,
		cols: fe.Columns,
	}, nil
}

func (r *CategoryRepositoryBase) FindOneByID(ctx context.Context, pk int64) (*CategoryEntity, error) {
	find := NewComposer(6)
	find.WriteString("SELECT ")
	if len(r.Columns) == 0 {
		find.WriteString("content, created_at, id, name, parent_id, updated_at")
	} else {
		find.WriteString(strings.Join(r.Columns, ", "))
	}
	find.WriteString(" FROM ")
	find.WriteString(TableCategory)
	find.WriteString(" WHERE ")
	find.WriteString(TableCategoryColumnID)
	find.WriteString("=")
	find.WritePlaceholder()
	find.Add(pk)
	var (
		ent CategoryEntity
	)
	props, err := ent.Props(r.Columns...)
	if err != nil {
		return nil, err
	}
	err = r.DB.QueryRowContext(ctx, find.String(), find.Args()...).Scan(props...)
	if r.Log != nil {
		r.Log(err, TableCategory, "find by primary key", find.String(), find.Args()...)
	}
	if err != nil {
		return nil, err
	}
	return &ent, nil
}

func (r *CategoryRepositoryBase) UpdateOneByIDQuery(pk int64, p *CategoryPatch) (string, []interface{}, error) {
	buf := bytes.NewBufferString("UPDATE ")
	buf.WriteString(r.Table)
	update := NewComposer(6)
	if p.Content.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableCategoryColumnContent); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.Content)
		update.Dirty = true

	}
	if p.CreatedAt.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableCategoryColumnCreatedAt); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.CreatedAt)
		update.Dirty = true

	}
	if p.Name.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableCategoryColumnName); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.Name)
		update.Dirty = true

	}
	if p.ParentID.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableCategoryColumnParentID); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.ParentID)
		update.Dirty = true

	}
	if p.UpdatedAt.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableCategoryColumnUpdatedAt); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.UpdatedAt)
		update.Dirty = true

	} else {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableCategoryColumnUpdatedAt); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("=NOW()"); err != nil {
			return "", nil, err
		}
		update.Dirty = true
	}
	if !update.Dirty {
		return "", nil, errors.New("Category update failure, nothing to update")
	}
	buf.WriteString(" SET ")
	buf.ReadFrom(update)
	buf.WriteString(" WHERE ")

	update.WriteString(TableCategoryColumnID)
	update.WriteString("=")
	update.WritePlaceholder()
	update.Add(pk)

	buf.ReadFrom(update)
	buf.WriteString(" RETURNING ")
	if len(r.Columns) > 0 {
		buf.WriteString(strings.Join(r.Columns, ", "))
	} else {
		buf.WriteString("content, created_at, id, name, parent_id, updated_at")
	}
	return buf.String(), update.Args(), nil
}

func (r *CategoryRepositoryBase) UpdateOneByID(ctx context.Context, pk int64, p *CategoryPatch) (*CategoryEntity, error) {
	query, args, err := r.UpdateOneByIDQuery(pk, p)
	if err != nil {
		return nil, err
	}
	var ent CategoryEntity
	props, err := ent.Props(r.Columns...)
	if err != nil {
		return nil, err
	}
	err = r.DB.QueryRowContext(ctx, query, args...).Scan(props...)
	if r.Log != nil {
		r.Log(err, TableCategory, "update by primary key", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return &ent, nil
}

func (r *CategoryRepositoryBase) FindOneByIDAndUpdate(ctx context.Context, pk int64, p *CategoryPatch) (before, after *CategoryEntity, err error) {
	find := NewComposer(6)
	find.WriteString("SELECT ")
	if len(r.Columns) == 0 {
		find.WriteString("content, created_at, id, name, parent_id, updated_at")
	} else {
		find.WriteString(strings.Join(r.Columns, ", "))
	}
	find.WriteString(" FROM ")
	find.WriteString(TableCategory)
	find.WriteString(" WHERE ")
	find.WriteString(TableCategoryColumnID)
	find.WriteString("=")
	find.WritePlaceholder()
	find.Add(pk)
	find.WriteString(" FOR UPDATE")
	query, args, err := r.UpdateOneByIDQuery(pk, p)
	if err != nil {
		return
	}
	var (
		oldEnt, newEnt CategoryEntity
	)
	oldProps, err := oldEnt.Props(r.Columns...)
	if err != nil {
		return
	}
	newProps, err := newEnt.Props(r.Columns...)
	if err != nil {
		return
	}
	tx, err := r.DB.Begin()
	if err != nil {
		return
	}
	err = tx.QueryRowContext(ctx, find.String(), find.Args()...).Scan(oldProps...)
	if r.Log != nil {
		r.Log(err, TableCategory, "find by primary key", find.String(), find.Args()...)
	}
	if err != nil {
		tx.Rollback()
		return
	}
	err = tx.QueryRowContext(ctx, query, args...).Scan(newProps...)
	if r.Log != nil {
		r.Log(err, TableCategory, "update by primary key", query, args...)
	}
	if err != nil {
		tx.Rollback()
		return
	}
	err = tx.Commit()
	if err != nil {
		return
	}
	return &oldEnt, &newEnt, nil
}

func (r *CategoryRepositoryBase) UpsertQuery(e *CategoryEntity, p *CategoryPatch, inf ...string) (string, []interface{}, error) {
	upsert := NewComposer(12)
	columns := bytes.NewBuffer(nil)
	buf := bytes.NewBufferString("INSERT INTO ")
	buf.WriteString(r.Table)

	if columns.Len() > 0 {
		if _, err := columns.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if _, err := columns.WriteString(TableCategoryColumnContent); err != nil {
		return "", nil, err
	}
	if upsert.Dirty {
		if _, err := upsert.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if err := upsert.WritePlaceholder(); err != nil {
		return "", nil, err
	}
	upsert.Add(e.Content)
	upsert.Dirty = true

	if !e.CreatedAt.IsZero() {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCategoryColumnCreatedAt); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.CreatedAt)
		upsert.Dirty = true
	}

	if columns.Len() > 0 {
		if _, err := columns.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if _, err := columns.WriteString(TableCategoryColumnName); err != nil {
		return "", nil, err
	}
	if upsert.Dirty {
		if _, err := upsert.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if err := upsert.WritePlaceholder(); err != nil {
		return "", nil, err
	}
	upsert.Add(e.Name)
	upsert.Dirty = true

	if e.ParentID.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCategoryColumnParentID); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ParentID)
		upsert.Dirty = true
	}

	if e.UpdatedAt.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCategoryColumnUpdatedAt); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.UpdatedAt)
		upsert.Dirty = true
	}

	if upsert.Dirty {
		buf.WriteString(" (")
		buf.ReadFrom(columns)
		buf.WriteString(") VALUES (")
		buf.ReadFrom(upsert)
		buf.WriteString(")")
	}
	buf.WriteString(" ON CONFLICT ")
	if len(inf) > 0 {
		upsert.Dirty = false
		if p.Content.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCategoryColumnContent); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.Content)
			upsert.Dirty = true

		}
		if p.CreatedAt.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCategoryColumnCreatedAt); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.CreatedAt)
			upsert.Dirty = true

		}
		if p.Name.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCategoryColumnName); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.Name)
			upsert.Dirty = true

		}
		if p.ParentID.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCategoryColumnParentID); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ParentID)
			upsert.Dirty = true

		}
		if p.UpdatedAt.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCategoryColumnUpdatedAt); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.UpdatedAt)
			upsert.Dirty = true

		} else {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCategoryColumnUpdatedAt); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("=NOW()"); err != nil {
				return "", nil, err
			}
			upsert.Dirty = true
		}
	}
	if len(inf) > 0 && upsert.Dirty {
		buf.WriteString("(")
		for j, i := range inf {
			if j != 0 {
				buf.WriteString(", ")
			}
			buf.WriteString(i)
		}
		buf.WriteString(")")
		buf.WriteString(" DO UPDATE SET ")
		buf.ReadFrom(upsert)
	} else {
		buf.WriteString(" DO NOTHING ")
	}
	if upsert.Dirty {
		buf.WriteString(" RETURNING ")
		if len(r.Columns) > 0 {
			buf.WriteString(strings.Join(r.Columns, ", "))
		} else {
			buf.WriteString("content, created_at, id, name, parent_id, updated_at")
		}
	}
	return buf.String(), upsert.Args(), nil
}

func (r *CategoryRepositoryBase) Upsert(ctx context.Context, e *CategoryEntity, p *CategoryPatch, inf ...string) (*CategoryEntity, error) {
	query, args, err := r.UpsertQuery(e, p, inf...)
	if err != nil {
		return nil, err
	}
	err = r.DB.QueryRowContext(ctx, query, args...).Scan(
		&e.Content,
		&e.CreatedAt,
		&e.ID,
		&e.Name,
		&e.ParentID,
		&e.UpdatedAt,
	)
	if r.Log != nil {
		r.Log(err, TableCategory, "upsert", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return e, nil
}

func (r *CategoryRepositoryBase) Count(ctx context.Context, c *CategoryCountExpr) (int64, error) {
	query, args, err := r.FindQuery(&CategoryFindExpr{
		Where:   c.Where,
		Columns: []string{"COUNT(*)"},
	})
	if err != nil {
		return 0, err
	}
	var count int64
	err = r.DB.QueryRowContext(ctx, query, args...).Scan(&count)
	if r.Log != nil {
		r.Log(err, TableCategory, "count", query, args...)
	}
	if err != nil {
		return 0, err
	}
	return count, nil
}

func (r *CategoryRepositoryBase) DeleteOneByID(ctx context.Context, pk int64) (int64, error) {
	find := NewComposer(6)
	find.WriteString("DELETE FROM ")
	find.WriteString(TableCategory)
	find.WriteString(" WHERE ")
	find.WriteString(TableCategoryColumnID)
	find.WriteString("=")
	find.WritePlaceholder()
	find.Add(pk)
	res, err := r.DB.ExecContext(ctx, find.String(), find.Args()...)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()
}

const (
	TablePackageConstraintPrimaryKey           = "example.package_id_pkey"
	TablePackageConstraintCategoryIDForeignKey = "example.package_category_id_fkey"
)

const (
	TablePackage                 = "example.package"
	TablePackageColumnBreak      = "break"
	TablePackageColumnCategoryID = "category_id"
	TablePackageColumnCreatedAt  = "created_at"
	TablePackageColumnID         = "id"
	TablePackageColumnUpdatedAt  = "updated_at"
)

var TablePackageColumns = []string{
	TablePackageColumnBreak,
	TablePackageColumnCategoryID,
	TablePackageColumnCreatedAt,
	TablePackageColumnID,
	TablePackageColumnUpdatedAt,
}

// PackageEntity ...
type PackageEntity struct {
	// Break ...
	Break sql.NullString
	// CategoryID ...
	CategoryID sql.NullInt64
	// CreatedAt ...
	CreatedAt time.Time
	// ID ...
	ID int64
	// UpdatedAt ...
	UpdatedAt pq.NullTime
	// Category ...
	Category *CategoryEntity
}

func (e *PackageEntity) Prop(cn string) (interface{}, bool) {
	switch cn {

	case TablePackageColumnBreak:
		return &e.Break, true
	case TablePackageColumnCategoryID:
		return &e.CategoryID, true
	case TablePackageColumnCreatedAt:
		return &e.CreatedAt, true
	case TablePackageColumnID:
		return &e.ID, true
	case TablePackageColumnUpdatedAt:
		return &e.UpdatedAt, true
	default:
		return nil, false
	}
}

func (e *PackageEntity) Props(cns ...string) ([]interface{}, error) {
	if len(cns) == 0 {
		cns = TablePackageColumns
	}
	res := make([]interface{}, 0, len(cns))
	for _, cn := range cns {
		if prop, ok := e.Prop(cn); ok {
			res = append(res, prop)
		} else {
			return nil, fmt.Errorf("unexpected column provided: %s", cn)
		}
	}
	return res, nil
}

// ScanPackageRows helps to scan rows straight to the slice of entities.
func ScanPackageRows(rows Rows) (entities []*PackageEntity, err error) {
	for rows.Next() {
		var ent PackageEntity
		err = rows.Scan(
			&ent.Break,
			&ent.CategoryID,
			&ent.CreatedAt,
			&ent.ID,
			&ent.UpdatedAt,
		)
		if err != nil {
			return
		}

		entities = append(entities, &ent)
	}
	if err = rows.Err(); err != nil {
		return
	}

	return
}

// PackageIterator is not thread safe.
type PackageIterator struct {
	rows Rows
	cols []string
	expr *PackageFindExpr
}

func (i *PackageIterator) Next() bool {
	return i.rows.Next()
}

func (i *PackageIterator) Close() error {
	return i.rows.Close()
}

func (i *PackageIterator) Err() error {
	return i.rows.Err()
}

// Columns is wrapper around sql.Rows.Columns method, that also cache output inside iterator.
func (i *PackageIterator) Columns() ([]string, error) {
	if i.cols == nil {
		cols, err := i.rows.Columns()
		if err != nil {
			return nil, err
		}
		i.cols = cols
	}
	return i.cols, nil
}

// Ent is wrapper around Package method that makes iterator more generic.
func (i *PackageIterator) Ent() (interface{}, error) {
	return i.Package()
}

func (i *PackageIterator) Package() (*PackageEntity, error) {
	var ent PackageEntity
	cols, err := i.Columns()
	if err != nil {
		return nil, err
	}

	props, err := ent.Props(cols...)
	if err != nil {
		return nil, err
	}
	var prop []interface{}
	if i.expr.JoinCategory != nil && i.expr.JoinCategory.Kind.Actionable() && i.expr.JoinCategory.Fetch {
		ent.Category = &CategoryEntity{}
		if prop, err = ent.Category.Props(); err != nil {
			return nil, err
		}
		props = append(props, prop...)
	}
	if err := i.rows.Scan(props...); err != nil {
		return nil, err
	}
	return &ent, nil
}

type PackageCriteria struct {
	Break                  sql.NullString
	CategoryID             sql.NullInt64
	CreatedAt              pq.NullTime
	ID                     sql.NullInt64
	UpdatedAt              pq.NullTime
	operator               string
	child, sibling, parent *PackageCriteria
}

func PackageOperand(operator string, operands ...*PackageCriteria) *PackageCriteria {
	if len(operands) == 0 {
		return &PackageCriteria{operator: operator}
	}

	parent := &PackageCriteria{
		operator: operator,
		child:    operands[0],
	}

	for i := 0; i < len(operands); i++ {
		if i < len(operands)-1 {
			operands[i].sibling = operands[i+1]
		}
		operands[i].parent = parent
	}

	return parent
}

func PackageOr(operands ...*PackageCriteria) *PackageCriteria {
	return PackageOperand("OR", operands...)
}

func PackageAnd(operands ...*PackageCriteria) *PackageCriteria {
	return PackageOperand("AND", operands...)
}

type PackageFindExpr struct {
	Where         *PackageCriteria
	Offset, Limit int64
	Columns       []string
	OrderBy       []RowOrder
	JoinCategory  *CategoryJoin
}

type PackageJoin struct {
	On, Where    *PackageCriteria
	Fetch        bool
	Kind         JoinType
	JoinCategory *CategoryJoin
}

type PackageCountExpr struct {
	Where        *PackageCriteria
	JoinCategory *CategoryJoin
}

type PackagePatch struct {
	Break      sql.NullString
	CategoryID sql.NullInt64
	CreatedAt  pq.NullTime
	UpdatedAt  pq.NullTime
}

type PackageRepositoryBase struct {
	Table   string
	Columns []string
	DB      *sql.DB
	Log     LogFunc
}

func (r *PackageRepositoryBase) InsertQuery(e *PackageEntity, read bool) (string, []interface{}, error) {
	insert := NewComposer(5)
	columns := bytes.NewBuffer(nil)
	buf := bytes.NewBufferString("INSERT INTO ")
	buf.WriteString(r.Table)

	if e.Break.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TablePackageColumnBreak); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.Break)
		insert.Dirty = true
	}

	if e.CategoryID.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TablePackageColumnCategoryID); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.CategoryID)
		insert.Dirty = true
	}

	if !e.CreatedAt.IsZero() {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TablePackageColumnCreatedAt); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.CreatedAt)
		insert.Dirty = true
	}

	if e.UpdatedAt.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TablePackageColumnUpdatedAt); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.UpdatedAt)
		insert.Dirty = true
	}

	if columns.Len() > 0 {
		buf.WriteString(" (")
		buf.ReadFrom(columns)
		buf.WriteString(") VALUES (")
		buf.ReadFrom(insert)
		buf.WriteString(") ")
		if read {
			buf.WriteString("RETURNING ")
			if len(r.Columns) > 0 {
				buf.WriteString(strings.Join(r.Columns, ", "))
			} else {
				buf.WriteString("break, category_id, created_at, id, updated_at")
			}
		}
	}
	return buf.String(), insert.Args(), nil
}

func (r *PackageRepositoryBase) Insert(ctx context.Context, e *PackageEntity) (*PackageEntity, error) {
	query, args, err := r.InsertQuery(e, true)
	if err != nil {
		return nil, err
	}
	err = r.DB.QueryRowContext(ctx, query, args...).Scan(
		&e.Break,
		&e.CategoryID,
		&e.CreatedAt,
		&e.ID,
		&e.UpdatedAt,
	)
	if r.Log != nil {
		r.Log(err, TablePackage, "insert", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return e, nil
}

func PackageCriteriaWhereClause(comp *Composer, c *PackageCriteria, id int) error {
	if c.child == nil {
		return _PackageCriteriaWhereClause(comp, c, id)
	}
	node := c
	sibling := false
	for {
		if !sibling {
			if node.child != nil {
				if node.parent != nil {
					comp.WriteString("(")
				}
				node = node.child
				continue
			} else {
				comp.Dirty = false
				comp.WriteString("(")
				if err := _PackageCriteriaWhereClause(comp, node, id); err != nil {
					return err
				}
				comp.WriteString(")")
			}
		}
		if node.sibling != nil {
			sibling = false
			comp.WriteString(" ")
			comp.WriteString(node.parent.operator)
			comp.WriteString(" ")
			node = node.sibling
			continue
		}
		if node.parent != nil {
			sibling = true
			if node.parent.parent != nil {
				comp.WriteString(")")
			}
			node = node.parent
			continue
		}

		break
	}
	return nil
}

func _PackageCriteriaWhereClause(comp *Composer, c *PackageCriteria, id int) error {
	if c.Break.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TablePackageColumnBreak); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.Break)
		comp.Dirty = true
	}
	if c.CategoryID.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TablePackageColumnCategoryID); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.CategoryID)
		comp.Dirty = true
	}
	if c.CreatedAt.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TablePackageColumnCreatedAt); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.CreatedAt)
		comp.Dirty = true
	}
	// id is an empty struct, ignore

	if c.UpdatedAt.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TablePackageColumnUpdatedAt); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.UpdatedAt)
		comp.Dirty = true
	}
	return nil
}

func (r *PackageRepositoryBase) FindQuery(fe *PackageFindExpr) (string, []interface{}, error) {
	comp := NewComposer(5)
	buf := bytes.NewBufferString("SELECT ")
	if len(fe.Columns) == 0 {
		buf.WriteString("t0.break, t0.category_id, t0.created_at, t0.id, t0.updated_at")
	} else {
		buf.WriteString(strings.Join(fe.Columns, ", "))
	}
	if fe.JoinCategory != nil && fe.JoinCategory.Kind.Actionable() && fe.JoinCategory.Fetch {
		buf.WriteString(", t1.content, t1.created_at, t1.id, t1.name, t1.parent_id, t1.updated_at")
	}
	buf.WriteString(" FROM ")
	buf.WriteString(r.Table)
	buf.WriteString(" AS t0")
	if fe.JoinCategory != nil && fe.JoinCategory.Kind.Actionable() {
		joinClause(comp, fe.JoinCategory.Kind, "example.category AS t1 ON t0.category_id=t1.id")
		if fe.JoinCategory.On != nil {
			comp.Dirty = true
			if err := CategoryCriteriaWhereClause(comp, fe.JoinCategory.On, 1); err != nil {
				return "", nil, err
			}
		}
	}
	if comp.Dirty {
		buf.ReadFrom(comp)
		comp.Dirty = false
	}
	if fe.Where != nil {
		if err := PackageCriteriaWhereClause(comp, fe.Where, 0); err != nil {
			return "", nil, err
		}
	}
	if fe.JoinCategory != nil && fe.JoinCategory.Kind.Actionable() && fe.JoinCategory.Where != nil {
		if err := CategoryCriteriaWhereClause(comp, fe.JoinCategory.Where, 1); err != nil {
			return "", nil, err
		}
	}
	if comp.Dirty {
		if _, err := buf.WriteString(" WHERE "); err != nil {
			return "", nil, err
		}
		buf.ReadFrom(comp)
	}

	if len(fe.OrderBy) > 0 {
		i := 0
		for _, order := range fe.OrderBy {
			for _, columnName := range TablePackageColumns {
				if order.Name == columnName {
					if i == 0 {
						comp.WriteString(" ORDER BY ")
					}
					if i > 0 {
						if _, err := comp.WriteString(", "); err != nil {
							return "", nil, err
						}
					}
					if _, err := comp.WriteString(order.Name); err != nil {
						return "", nil, err
					}
					if order.Descending {
						if _, err := comp.WriteString(" DESC"); err != nil {
							return "", nil, err
						}
					}
					i++
					break
				}
			}
		}
	}
	if fe.Offset > 0 {
		if _, err := comp.WriteString(" OFFSET "); err != nil {
			return "", nil, err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		if _, err := comp.WriteString(" "); err != nil {
			return "", nil, err
		}
		comp.Add(fe.Offset)
	}
	if fe.Limit > 0 {
		if _, err := comp.WriteString(" LIMIT "); err != nil {
			return "", nil, err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		if _, err := comp.WriteString(" "); err != nil {
			return "", nil, err
		}
		comp.Add(fe.Limit)
	}

	buf.ReadFrom(comp)

	return buf.String(), comp.Args(), nil
}

func (r *PackageRepositoryBase) Find(ctx context.Context, fe *PackageFindExpr) ([]*PackageEntity, error) {
	query, args, err := r.FindQuery(fe)
	if err != nil {
		return nil, err
	}
	rows, err := r.DB.QueryContext(ctx, query, args...)
	if r.Log != nil {
		r.Log(err, TablePackage, "find", query, args...)
	}
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var (
		entities []*PackageEntity
		props    []interface{}
	)
	for rows.Next() {
		var ent PackageEntity
		if props, err = ent.Props(); err != nil {
			return nil, err
		}
		var prop []interface{}
		if fe.JoinCategory != nil && fe.JoinCategory.Kind.Actionable() && fe.JoinCategory.Fetch {
			ent.Category = &CategoryEntity{}
			if prop, err = ent.Category.Props(); err != nil {
				return nil, err
			}
			props = append(props, prop...)
		}
		err = rows.Scan(props...)
		if err != nil {
			return nil, err
		}

		entities = append(entities, &ent)
	}
	err = rows.Err()
	if r.Log != nil {
		r.Log(err, TablePackage, "find", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return entities, nil
}

func (r *PackageRepositoryBase) FindIter(ctx context.Context, fe *PackageFindExpr) (*PackageIterator, error) {
	query, args, err := r.FindQuery(fe)
	if err != nil {
		return nil, err
	}
	rows, err := r.DB.QueryContext(ctx, query, args...)
	if r.Log != nil {
		r.Log(err, TablePackage, "find iter", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return &PackageIterator{
		rows: rows,
		expr: fe,
		cols: fe.Columns,
	}, nil
}

func (r *PackageRepositoryBase) FindOneByID(ctx context.Context, pk int64) (*PackageEntity, error) {
	find := NewComposer(5)
	find.WriteString("SELECT ")
	if len(r.Columns) == 0 {
		find.WriteString("break, category_id, created_at, id, updated_at")
	} else {
		find.WriteString(strings.Join(r.Columns, ", "))
	}
	find.WriteString(" FROM ")
	find.WriteString(TablePackage)
	find.WriteString(" WHERE ")
	find.WriteString(TablePackageColumnID)
	find.WriteString("=")
	find.WritePlaceholder()
	find.Add(pk)
	var (
		ent PackageEntity
	)
	props, err := ent.Props(r.Columns...)
	if err != nil {
		return nil, err
	}
	err = r.DB.QueryRowContext(ctx, find.String(), find.Args()...).Scan(props...)
	if r.Log != nil {
		r.Log(err, TablePackage, "find by primary key", find.String(), find.Args()...)
	}
	if err != nil {
		return nil, err
	}
	return &ent, nil
}

func (r *PackageRepositoryBase) UpdateOneByIDQuery(pk int64, p *PackagePatch) (string, []interface{}, error) {
	buf := bytes.NewBufferString("UPDATE ")
	buf.WriteString(r.Table)
	update := NewComposer(5)
	if p.Break.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TablePackageColumnBreak); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.Break)
		update.Dirty = true

	}
	if p.CategoryID.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TablePackageColumnCategoryID); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.CategoryID)
		update.Dirty = true

	}
	if p.CreatedAt.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TablePackageColumnCreatedAt); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.CreatedAt)
		update.Dirty = true

	}
	if p.UpdatedAt.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TablePackageColumnUpdatedAt); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.UpdatedAt)
		update.Dirty = true

	} else {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TablePackageColumnUpdatedAt); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("=NOW()"); err != nil {
			return "", nil, err
		}
		update.Dirty = true
	}
	if !update.Dirty {
		return "", nil, errors.New("Package update failure, nothing to update")
	}
	buf.WriteString(" SET ")
	buf.ReadFrom(update)
	buf.WriteString(" WHERE ")

	update.WriteString(TablePackageColumnID)
	update.WriteString("=")
	update.WritePlaceholder()
	update.Add(pk)

	buf.ReadFrom(update)
	buf.WriteString(" RETURNING ")
	if len(r.Columns) > 0 {
		buf.WriteString(strings.Join(r.Columns, ", "))
	} else {
		buf.WriteString("break, category_id, created_at, id, updated_at")
	}
	return buf.String(), update.Args(), nil
}

func (r *PackageRepositoryBase) UpdateOneByID(ctx context.Context, pk int64, p *PackagePatch) (*PackageEntity, error) {
	query, args, err := r.UpdateOneByIDQuery(pk, p)
	if err != nil {
		return nil, err
	}
	var ent PackageEntity
	props, err := ent.Props(r.Columns...)
	if err != nil {
		return nil, err
	}
	err = r.DB.QueryRowContext(ctx, query, args...).Scan(props...)
	if r.Log != nil {
		r.Log(err, TablePackage, "update by primary key", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return &ent, nil
}

func (r *PackageRepositoryBase) FindOneByIDAndUpdate(ctx context.Context, pk int64, p *PackagePatch) (before, after *PackageEntity, err error) {
	find := NewComposer(5)
	find.WriteString("SELECT ")
	if len(r.Columns) == 0 {
		find.WriteString("break, category_id, created_at, id, updated_at")
	} else {
		find.WriteString(strings.Join(r.Columns, ", "))
	}
	find.WriteString(" FROM ")
	find.WriteString(TablePackage)
	find.WriteString(" WHERE ")
	find.WriteString(TablePackageColumnID)
	find.WriteString("=")
	find.WritePlaceholder()
	find.Add(pk)
	find.WriteString(" FOR UPDATE")
	query, args, err := r.UpdateOneByIDQuery(pk, p)
	if err != nil {
		return
	}
	var (
		oldEnt, newEnt PackageEntity
	)
	oldProps, err := oldEnt.Props(r.Columns...)
	if err != nil {
		return
	}
	newProps, err := newEnt.Props(r.Columns...)
	if err != nil {
		return
	}
	tx, err := r.DB.Begin()
	if err != nil {
		return
	}
	err = tx.QueryRowContext(ctx, find.String(), find.Args()...).Scan(oldProps...)
	if r.Log != nil {
		r.Log(err, TablePackage, "find by primary key", find.String(), find.Args()...)
	}
	if err != nil {
		tx.Rollback()
		return
	}
	err = tx.QueryRowContext(ctx, query, args...).Scan(newProps...)
	if r.Log != nil {
		r.Log(err, TablePackage, "update by primary key", query, args...)
	}
	if err != nil {
		tx.Rollback()
		return
	}
	err = tx.Commit()
	if err != nil {
		return
	}
	return &oldEnt, &newEnt, nil
}

func (r *PackageRepositoryBase) UpsertQuery(e *PackageEntity, p *PackagePatch, inf ...string) (string, []interface{}, error) {
	upsert := NewComposer(10)
	columns := bytes.NewBuffer(nil)
	buf := bytes.NewBufferString("INSERT INTO ")
	buf.WriteString(r.Table)

	if e.Break.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TablePackageColumnBreak); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.Break)
		upsert.Dirty = true
	}

	if e.CategoryID.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TablePackageColumnCategoryID); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.CategoryID)
		upsert.Dirty = true
	}

	if !e.CreatedAt.IsZero() {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TablePackageColumnCreatedAt); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.CreatedAt)
		upsert.Dirty = true
	}

	if e.UpdatedAt.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TablePackageColumnUpdatedAt); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.UpdatedAt)
		upsert.Dirty = true
	}

	if upsert.Dirty {
		buf.WriteString(" (")
		buf.ReadFrom(columns)
		buf.WriteString(") VALUES (")
		buf.ReadFrom(upsert)
		buf.WriteString(")")
	}
	buf.WriteString(" ON CONFLICT ")
	if len(inf) > 0 {
		upsert.Dirty = false
		if p.Break.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TablePackageColumnBreak); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.Break)
			upsert.Dirty = true

		}
		if p.CategoryID.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TablePackageColumnCategoryID); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.CategoryID)
			upsert.Dirty = true

		}
		if p.CreatedAt.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TablePackageColumnCreatedAt); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.CreatedAt)
			upsert.Dirty = true

		}
		if p.UpdatedAt.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TablePackageColumnUpdatedAt); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.UpdatedAt)
			upsert.Dirty = true

		} else {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TablePackageColumnUpdatedAt); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("=NOW()"); err != nil {
				return "", nil, err
			}
			upsert.Dirty = true
		}
	}
	if len(inf) > 0 && upsert.Dirty {
		buf.WriteString("(")
		for j, i := range inf {
			if j != 0 {
				buf.WriteString(", ")
			}
			buf.WriteString(i)
		}
		buf.WriteString(")")
		buf.WriteString(" DO UPDATE SET ")
		buf.ReadFrom(upsert)
	} else {
		buf.WriteString(" DO NOTHING ")
	}
	if upsert.Dirty {
		buf.WriteString(" RETURNING ")
		if len(r.Columns) > 0 {
			buf.WriteString(strings.Join(r.Columns, ", "))
		} else {
			buf.WriteString("break, category_id, created_at, id, updated_at")
		}
	}
	return buf.String(), upsert.Args(), nil
}

func (r *PackageRepositoryBase) Upsert(ctx context.Context, e *PackageEntity, p *PackagePatch, inf ...string) (*PackageEntity, error) {
	query, args, err := r.UpsertQuery(e, p, inf...)
	if err != nil {
		return nil, err
	}
	err = r.DB.QueryRowContext(ctx, query, args...).Scan(
		&e.Break,
		&e.CategoryID,
		&e.CreatedAt,
		&e.ID,
		&e.UpdatedAt,
	)
	if r.Log != nil {
		r.Log(err, TablePackage, "upsert", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return e, nil
}

func (r *PackageRepositoryBase) Count(ctx context.Context, c *PackageCountExpr) (int64, error) {
	query, args, err := r.FindQuery(&PackageFindExpr{
		Where:   c.Where,
		Columns: []string{"COUNT(*)"},

		JoinCategory: c.JoinCategory,
	})
	if err != nil {
		return 0, err
	}
	var count int64
	err = r.DB.QueryRowContext(ctx, query, args...).Scan(&count)
	if r.Log != nil {
		r.Log(err, TablePackage, "count", query, args...)
	}
	if err != nil {
		return 0, err
	}
	return count, nil
}

func (r *PackageRepositoryBase) DeleteOneByID(ctx context.Context, pk int64) (int64, error) {
	find := NewComposer(5)
	find.WriteString("DELETE FROM ")
	find.WriteString(TablePackage)
	find.WriteString(" WHERE ")
	find.WriteString(TablePackageColumnID)
	find.WriteString("=")
	find.WritePlaceholder()
	find.Add(pk)
	res, err := r.DB.ExecContext(ctx, find.String(), find.Args()...)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()
}

const (
	TableNewsConstraintPrimaryKey      = "example.news_id_pkey"
	TableNewsConstraintTitleUnique     = "example.news_title_key"
	TableNewsConstraintTitleLeadUnique = "example.news_title_lead_key"
)

const (
	TableNews                        = "example.news"
	TableNewsColumnContent           = "content"
	TableNewsColumnContinue          = "continue"
	TableNewsColumnCreatedAt         = "created_at"
	TableNewsColumnDay               = "day"
	TableNewsColumnID                = "id"
	TableNewsColumnLead              = "lead"
	TableNewsColumnMetaData          = "meta_data"
	TableNewsColumnScore             = "score"
	TableNewsColumnTitle             = "title"
	TableNewsColumnUpdatedAt         = "updated_at"
	TableNewsColumnVersion           = "version"
	TableNewsColumnViewsDistribution = "views_distribution"
)

var TableNewsColumns = []string{
	TableNewsColumnContent,
	TableNewsColumnContinue,
	TableNewsColumnCreatedAt,
	TableNewsColumnDay,
	TableNewsColumnID,
	TableNewsColumnLead,
	TableNewsColumnMetaData,
	TableNewsColumnScore,
	TableNewsColumnTitle,
	TableNewsColumnUpdatedAt,
	TableNewsColumnVersion,
	TableNewsColumnViewsDistribution,
}

// NewsEntity ...
type NewsEntity struct {
	// Content ...
	Content string
	// Continue ...
	Continue bool
	// CreatedAt ...
	CreatedAt time.Time
	// Day ...
	Day pq.NullTime
	// ID ...
	ID int64
	// Lead ...
	Lead sql.NullString
	// MetaData ...
	MetaData []byte
	// Score ...
	Score float64
	// Title ...
	Title string
	// UpdatedAt ...
	UpdatedAt pq.NullTime
	// Version ...
	Version int64
	// ViewsDistribution ...
	ViewsDistribution NullFloat64Array
	// CommentsByNewsTitle ...
	CommentsByNewsTitle []*CommentEntity
	// Comments ...
	Comments []*CommentEntity
}

func (e *NewsEntity) Prop(cn string) (interface{}, bool) {
	switch cn {

	case TableNewsColumnContent:
		return &e.Content, true
	case TableNewsColumnContinue:
		return &e.Continue, true
	case TableNewsColumnCreatedAt:
		return &e.CreatedAt, true
	case TableNewsColumnDay:
		return &e.Day, true
	case TableNewsColumnID:
		return &e.ID, true
	case TableNewsColumnLead:
		return &e.Lead, true
	case TableNewsColumnMetaData:
		return &e.MetaData, true
	case TableNewsColumnScore:
		return &e.Score, true
	case TableNewsColumnTitle:
		return &e.Title, true
	case TableNewsColumnUpdatedAt:
		return &e.UpdatedAt, true
	case TableNewsColumnVersion:
		return &e.Version, true
	case TableNewsColumnViewsDistribution:
		return &e.ViewsDistribution, true
	default:
		return nil, false
	}
}

func (e *NewsEntity) Props(cns ...string) ([]interface{}, error) {
	if len(cns) == 0 {
		cns = TableNewsColumns
	}
	res := make([]interface{}, 0, len(cns))
	for _, cn := range cns {
		if prop, ok := e.Prop(cn); ok {
			res = append(res, prop)
		} else {
			return nil, fmt.Errorf("unexpected column provided: %s", cn)
		}
	}
	return res, nil
}

// ScanNewsRows helps to scan rows straight to the slice of entities.
func ScanNewsRows(rows Rows) (entities []*NewsEntity, err error) {
	for rows.Next() {
		var ent NewsEntity
		err = rows.Scan(
			&ent.Content,
			&ent.Continue,
			&ent.CreatedAt,
			&ent.Day,
			&ent.ID,
			&ent.Lead,
			&ent.MetaData,
			&ent.Score,
			&ent.Title,
			&ent.UpdatedAt,
			&ent.Version,
			&ent.ViewsDistribution,
		)
		if err != nil {
			return
		}

		entities = append(entities, &ent)
	}
	if err = rows.Err(); err != nil {
		return
	}

	return
}

// NewsIterator is not thread safe.
type NewsIterator struct {
	rows Rows
	cols []string
	expr *NewsFindExpr
}

func (i *NewsIterator) Next() bool {
	return i.rows.Next()
}

func (i *NewsIterator) Close() error {
	return i.rows.Close()
}

func (i *NewsIterator) Err() error {
	return i.rows.Err()
}

// Columns is wrapper around sql.Rows.Columns method, that also cache output inside iterator.
func (i *NewsIterator) Columns() ([]string, error) {
	if i.cols == nil {
		cols, err := i.rows.Columns()
		if err != nil {
			return nil, err
		}
		i.cols = cols
	}
	return i.cols, nil
}

// Ent is wrapper around News method that makes iterator more generic.
func (i *NewsIterator) Ent() (interface{}, error) {
	return i.News()
}

func (i *NewsIterator) News() (*NewsEntity, error) {
	var ent NewsEntity
	cols, err := i.Columns()
	if err != nil {
		return nil, err
	}

	props, err := ent.Props(cols...)
	if err != nil {
		return nil, err
	}
	if err := i.rows.Scan(props...); err != nil {
		return nil, err
	}
	return &ent, nil
}

type NewsCriteria struct {
	Content                sql.NullString
	Continue               sql.NullBool
	CreatedAt              pq.NullTime
	Day                    pq.NullTime
	ID                     sql.NullInt64
	Lead                   sql.NullString
	MetaData               []byte
	Score                  sql.NullFloat64
	Title                  sql.NullString
	UpdatedAt              pq.NullTime
	Version                sql.NullInt64
	ViewsDistribution      NullFloat64Array
	operator               string
	child, sibling, parent *NewsCriteria
}

func NewsOperand(operator string, operands ...*NewsCriteria) *NewsCriteria {
	if len(operands) == 0 {
		return &NewsCriteria{operator: operator}
	}

	parent := &NewsCriteria{
		operator: operator,
		child:    operands[0],
	}

	for i := 0; i < len(operands); i++ {
		if i < len(operands)-1 {
			operands[i].sibling = operands[i+1]
		}
		operands[i].parent = parent
	}

	return parent
}

func NewsOr(operands ...*NewsCriteria) *NewsCriteria {
	return NewsOperand("OR", operands...)
}

func NewsAnd(operands ...*NewsCriteria) *NewsCriteria {
	return NewsOperand("AND", operands...)
}

type NewsFindExpr struct {
	Where         *NewsCriteria
	Offset, Limit int64
	Columns       []string
	OrderBy       []RowOrder
}

type NewsJoin struct {
	On, Where *NewsCriteria
	Fetch     bool
	Kind      JoinType
}

type NewsCountExpr struct {
	Where *NewsCriteria
}

type NewsPatch struct {
	Content           sql.NullString
	Continue          sql.NullBool
	CreatedAt         pq.NullTime
	Day               pq.NullTime
	Lead              sql.NullString
	MetaData          []byte
	Score             sql.NullFloat64
	Title             sql.NullString
	UpdatedAt         pq.NullTime
	Version           sql.NullInt64
	ViewsDistribution NullFloat64Array
}

type NewsRepositoryBase struct {
	Table   string
	Columns []string
	DB      *sql.DB
	Log     LogFunc
}

func (r *NewsRepositoryBase) InsertQuery(e *NewsEntity, read bool) (string, []interface{}, error) {
	insert := NewComposer(12)
	columns := bytes.NewBuffer(nil)
	buf := bytes.NewBufferString("INSERT INTO ")
	buf.WriteString(r.Table)

	if columns.Len() > 0 {
		if _, err := columns.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if _, err := columns.WriteString(TableNewsColumnContent); err != nil {
		return "", nil, err
	}
	if insert.Dirty {
		if _, err := insert.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if err := insert.WritePlaceholder(); err != nil {
		return "", nil, err
	}
	insert.Add(e.Content)
	insert.Dirty = true

	if columns.Len() > 0 {
		if _, err := columns.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if _, err := columns.WriteString(TableNewsColumnContinue); err != nil {
		return "", nil, err
	}
	if insert.Dirty {
		if _, err := insert.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if err := insert.WritePlaceholder(); err != nil {
		return "", nil, err
	}
	insert.Add(e.Continue)
	insert.Dirty = true

	if !e.CreatedAt.IsZero() {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableNewsColumnCreatedAt); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.CreatedAt)
		insert.Dirty = true
	}

	if e.Day.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableNewsColumnDay); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.Day)
		insert.Dirty = true
	}

	if e.Lead.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableNewsColumnLead); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.Lead)
		insert.Dirty = true
	}

	if e.MetaData != nil {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableNewsColumnMetaData); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.MetaData)
		insert.Dirty = true
	}

	if columns.Len() > 0 {
		if _, err := columns.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if _, err := columns.WriteString(TableNewsColumnScore); err != nil {
		return "", nil, err
	}
	if insert.Dirty {
		if _, err := insert.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if err := insert.WritePlaceholder(); err != nil {
		return "", nil, err
	}
	insert.Add(e.Score)
	insert.Dirty = true

	if columns.Len() > 0 {
		if _, err := columns.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if _, err := columns.WriteString(TableNewsColumnTitle); err != nil {
		return "", nil, err
	}
	if insert.Dirty {
		if _, err := insert.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if err := insert.WritePlaceholder(); err != nil {
		return "", nil, err
	}
	insert.Add(e.Title)
	insert.Dirty = true

	if e.UpdatedAt.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableNewsColumnUpdatedAt); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.UpdatedAt)
		insert.Dirty = true
	}

	if columns.Len() > 0 {
		if _, err := columns.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if _, err := columns.WriteString(TableNewsColumnVersion); err != nil {
		return "", nil, err
	}
	if insert.Dirty {
		if _, err := insert.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if err := insert.WritePlaceholder(); err != nil {
		return "", nil, err
	}
	insert.Add(e.Version)
	insert.Dirty = true

	if e.ViewsDistribution.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableNewsColumnViewsDistribution); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ViewsDistribution)
		insert.Dirty = true
	}

	if columns.Len() > 0 {
		buf.WriteString(" (")
		buf.ReadFrom(columns)
		buf.WriteString(") VALUES (")
		buf.ReadFrom(insert)
		buf.WriteString(") ")
		if read {
			buf.WriteString("RETURNING ")
			if len(r.Columns) > 0 {
				buf.WriteString(strings.Join(r.Columns, ", "))
			} else {
				buf.WriteString("content, continue, created_at, day, id, lead, meta_data, score, title, updated_at, version, views_distribution")
			}
		}
	}
	return buf.String(), insert.Args(), nil
}

func (r *NewsRepositoryBase) Insert(ctx context.Context, e *NewsEntity) (*NewsEntity, error) {
	query, args, err := r.InsertQuery(e, true)
	if err != nil {
		return nil, err
	}
	err = r.DB.QueryRowContext(ctx, query, args...).Scan(
		&e.Content,
		&e.Continue,
		&e.CreatedAt,
		&e.Day,
		&e.ID,
		&e.Lead,
		&e.MetaData,
		&e.Score,
		&e.Title,
		&e.UpdatedAt,
		&e.Version,
		&e.ViewsDistribution,
	)
	if r.Log != nil {
		r.Log(err, TableNews, "insert", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return e, nil
}

func NewsCriteriaWhereClause(comp *Composer, c *NewsCriteria, id int) error {
	if c.child == nil {
		return _NewsCriteriaWhereClause(comp, c, id)
	}
	node := c
	sibling := false
	for {
		if !sibling {
			if node.child != nil {
				if node.parent != nil {
					comp.WriteString("(")
				}
				node = node.child
				continue
			} else {
				comp.Dirty = false
				comp.WriteString("(")
				if err := _NewsCriteriaWhereClause(comp, node, id); err != nil {
					return err
				}
				comp.WriteString(")")
			}
		}
		if node.sibling != nil {
			sibling = false
			comp.WriteString(" ")
			comp.WriteString(node.parent.operator)
			comp.WriteString(" ")
			node = node.sibling
			continue
		}
		if node.parent != nil {
			sibling = true
			if node.parent.parent != nil {
				comp.WriteString(")")
			}
			node = node.parent
			continue
		}

		break
	}
	return nil
}

func _NewsCriteriaWhereClause(comp *Composer, c *NewsCriteria, id int) error {
	if c.Content.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableNewsColumnContent); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.Content)
		comp.Dirty = true
	}
	if c.Continue.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableNewsColumnContinue); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.Continue)
		comp.Dirty = true
	}
	if c.CreatedAt.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableNewsColumnCreatedAt); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.CreatedAt)
		comp.Dirty = true
	}
	if c.Day.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableNewsColumnDay); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.Day)
		comp.Dirty = true
	}
	// id is an empty struct, ignore

	if c.Lead.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableNewsColumnLead); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.Lead)
		comp.Dirty = true
	}
	if c.MetaData != nil {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableNewsColumnMetaData); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.MetaData)
		comp.Dirty = true
	}
	if c.Score.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableNewsColumnScore); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.Score)
		comp.Dirty = true
	}
	if c.Title.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableNewsColumnTitle); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.Title)
		comp.Dirty = true
	}
	if c.UpdatedAt.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableNewsColumnUpdatedAt); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.UpdatedAt)
		comp.Dirty = true
	}
	if c.Version.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableNewsColumnVersion); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.Version)
		comp.Dirty = true
	}
	if c.ViewsDistribution.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableNewsColumnViewsDistribution); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ViewsDistribution)
		comp.Dirty = true
	}
	return nil
}

func (r *NewsRepositoryBase) FindQuery(fe *NewsFindExpr) (string, []interface{}, error) {
	comp := NewComposer(12)
	buf := bytes.NewBufferString("SELECT ")
	if len(fe.Columns) == 0 {
		buf.WriteString("t0.content, t0.continue, t0.created_at, t0.day, t0.id, t0.lead, t0.meta_data, t0.score, t0.title, t0.updated_at, t0.version, t0.views_distribution")
	} else {
		buf.WriteString(strings.Join(fe.Columns, ", "))
	}
	buf.WriteString(" FROM ")
	buf.WriteString(r.Table)
	buf.WriteString(" AS t0")
	if comp.Dirty {
		buf.ReadFrom(comp)
		comp.Dirty = false
	}
	if fe.Where != nil {
		if err := NewsCriteriaWhereClause(comp, fe.Where, 0); err != nil {
			return "", nil, err
		}
	}
	if comp.Dirty {
		if _, err := buf.WriteString(" WHERE "); err != nil {
			return "", nil, err
		}
		buf.ReadFrom(comp)
	}

	if len(fe.OrderBy) > 0 {
		i := 0
		for _, order := range fe.OrderBy {
			for _, columnName := range TableNewsColumns {
				if order.Name == columnName {
					if i == 0 {
						comp.WriteString(" ORDER BY ")
					}
					if i > 0 {
						if _, err := comp.WriteString(", "); err != nil {
							return "", nil, err
						}
					}
					if _, err := comp.WriteString(order.Name); err != nil {
						return "", nil, err
					}
					if order.Descending {
						if _, err := comp.WriteString(" DESC"); err != nil {
							return "", nil, err
						}
					}
					i++
					break
				}
			}
		}
	}
	if fe.Offset > 0 {
		if _, err := comp.WriteString(" OFFSET "); err != nil {
			return "", nil, err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		if _, err := comp.WriteString(" "); err != nil {
			return "", nil, err
		}
		comp.Add(fe.Offset)
	}
	if fe.Limit > 0 {
		if _, err := comp.WriteString(" LIMIT "); err != nil {
			return "", nil, err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		if _, err := comp.WriteString(" "); err != nil {
			return "", nil, err
		}
		comp.Add(fe.Limit)
	}

	buf.ReadFrom(comp)

	return buf.String(), comp.Args(), nil
}

func (r *NewsRepositoryBase) Find(ctx context.Context, fe *NewsFindExpr) ([]*NewsEntity, error) {
	query, args, err := r.FindQuery(fe)
	if err != nil {
		return nil, err
	}
	rows, err := r.DB.QueryContext(ctx, query, args...)
	if r.Log != nil {
		r.Log(err, TableNews, "find", query, args...)
	}
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var (
		entities []*NewsEntity
		props    []interface{}
	)
	for rows.Next() {
		var ent NewsEntity
		if props, err = ent.Props(); err != nil {
			return nil, err
		}
		err = rows.Scan(props...)
		if err != nil {
			return nil, err
		}

		entities = append(entities, &ent)
	}
	err = rows.Err()
	if r.Log != nil {
		r.Log(err, TableNews, "find", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return entities, nil
}

func (r *NewsRepositoryBase) FindIter(ctx context.Context, fe *NewsFindExpr) (*NewsIterator, error) {
	query, args, err := r.FindQuery(fe)
	if err != nil {
		return nil, err
	}
	rows, err := r.DB.QueryContext(ctx, query, args...)
	if r.Log != nil {
		r.Log(err, TableNews, "find iter", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return &NewsIterator{
		rows: rows,
		expr: fe,
		cols: fe.Columns,
	}, nil
}

func (r *NewsRepositoryBase) FindOneByID(ctx context.Context, pk int64) (*NewsEntity, error) {
	find := NewComposer(12)
	find.WriteString("SELECT ")
	if len(r.Columns) == 0 {
		find.WriteString("content, continue, created_at, day, id, lead, meta_data, score, title, updated_at, version, views_distribution")
	} else {
		find.WriteString(strings.Join(r.Columns, ", "))
	}
	find.WriteString(" FROM ")
	find.WriteString(TableNews)
	find.WriteString(" WHERE ")
	find.WriteString(TableNewsColumnID)
	find.WriteString("=")
	find.WritePlaceholder()
	find.Add(pk)
	var (
		ent NewsEntity
	)
	props, err := ent.Props(r.Columns...)
	if err != nil {
		return nil, err
	}
	err = r.DB.QueryRowContext(ctx, find.String(), find.Args()...).Scan(props...)
	if r.Log != nil {
		r.Log(err, TableNews, "find by primary key", find.String(), find.Args()...)
	}
	if err != nil {
		return nil, err
	}
	return &ent, nil
}

func (r *NewsRepositoryBase) FindOneByTitle(ctx context.Context, newsTitle string) (*NewsEntity, error) {
	find := NewComposer(12)
	find.WriteString("SELECT ")
	if len(r.Columns) == 0 {
		find.WriteString("content, continue, created_at, day, id, lead, meta_data, score, title, updated_at, version, views_distribution")
	} else {
		find.WriteString(strings.Join(r.Columns, ", "))
	}
	find.WriteString(" FROM ")
	find.WriteString(TableNews)
	find.WriteString(" WHERE ")
	find.WriteString(TableNewsColumnTitle)
	find.WriteString("=")
	find.WritePlaceholder()
	find.Add(newsTitle)

	var (
		ent NewsEntity
	)
	props, err := ent.Props(r.Columns...)
	if err != nil {
		return nil, err
	}
	err = r.DB.QueryRowContext(ctx, find.String(), find.Args()...).Scan(props...)
	if err != nil {
		return nil, err
	}

	return &ent, nil
}

func (r *NewsRepositoryBase) FindOneByTitleAndLead(ctx context.Context, newsTitle string, newsLead string) (*NewsEntity, error) {
	find := NewComposer(12)
	find.WriteString("SELECT ")
	if len(r.Columns) == 0 {
		find.WriteString("content, continue, created_at, day, id, lead, meta_data, score, title, updated_at, version, views_distribution")
	} else {
		find.WriteString(strings.Join(r.Columns, ", "))
	}
	find.WriteString(" FROM ")
	find.WriteString(TableNews)
	find.WriteString(" WHERE ")
	find.WriteString(TableNewsColumnTitle)
	find.WriteString("=")
	find.WritePlaceholder()
	find.Add(newsTitle)
	find.WriteString(" AND ")
	find.WriteString(TableNewsColumnLead)
	find.WriteString("=")
	find.WritePlaceholder()
	find.Add(newsLead)

	var (
		ent NewsEntity
	)
	props, err := ent.Props(r.Columns...)
	if err != nil {
		return nil, err
	}
	err = r.DB.QueryRowContext(ctx, find.String(), find.Args()...).Scan(props...)
	if err != nil {
		return nil, err
	}

	return &ent, nil
}

func (r *NewsRepositoryBase) UpdateOneByIDQuery(pk int64, p *NewsPatch) (string, []interface{}, error) {
	buf := bytes.NewBufferString("UPDATE ")
	buf.WriteString(r.Table)
	update := NewComposer(12)
	if p.Content.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnContent); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.Content)
		update.Dirty = true

	}
	if p.Continue.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnContinue); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.Continue)
		update.Dirty = true

	}
	if p.CreatedAt.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnCreatedAt); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.CreatedAt)
		update.Dirty = true

	}
	if p.Day.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnDay); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.Day)
		update.Dirty = true

	}
	if p.Lead.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnLead); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.Lead)
		update.Dirty = true

	}
	if p.MetaData != nil {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnMetaData); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.MetaData)
		update.Dirty = true

	}
	if p.Score.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnScore); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.Score)
		update.Dirty = true

	}
	if p.Title.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnTitle); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.Title)
		update.Dirty = true

	}
	if p.UpdatedAt.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnUpdatedAt); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.UpdatedAt)
		update.Dirty = true

	} else {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnUpdatedAt); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("=NOW()"); err != nil {
			return "", nil, err
		}
		update.Dirty = true
	}
	if p.Version.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnVersion); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.Version)
		update.Dirty = true

	} else {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnVersion); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("=version+1"); err != nil {
			return "", nil, err
		}
		update.Dirty = true
	}
	if p.ViewsDistribution.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnViewsDistribution); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.ViewsDistribution)
		update.Dirty = true

	}
	if !update.Dirty {
		return "", nil, errors.New("News update failure, nothing to update")
	}
	buf.WriteString(" SET ")
	buf.ReadFrom(update)
	buf.WriteString(" WHERE ")

	update.WriteString(TableNewsColumnID)
	update.WriteString("=")
	update.WritePlaceholder()
	update.Add(pk)

	buf.ReadFrom(update)
	buf.WriteString(" RETURNING ")
	if len(r.Columns) > 0 {
		buf.WriteString(strings.Join(r.Columns, ", "))
	} else {
		buf.WriteString("content, continue, created_at, day, id, lead, meta_data, score, title, updated_at, version, views_distribution")
	}
	return buf.String(), update.Args(), nil
}

func (r *NewsRepositoryBase) UpdateOneByID(ctx context.Context, pk int64, p *NewsPatch) (*NewsEntity, error) {
	query, args, err := r.UpdateOneByIDQuery(pk, p)
	if err != nil {
		return nil, err
	}
	var ent NewsEntity
	props, err := ent.Props(r.Columns...)
	if err != nil {
		return nil, err
	}
	err = r.DB.QueryRowContext(ctx, query, args...).Scan(props...)
	if r.Log != nil {
		r.Log(err, TableNews, "update by primary key", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return &ent, nil
}

func (r *NewsRepositoryBase) FindOneByIDAndUpdate(ctx context.Context, pk int64, p *NewsPatch) (before, after *NewsEntity, err error) {
	find := NewComposer(12)
	find.WriteString("SELECT ")
	if len(r.Columns) == 0 {
		find.WriteString("content, continue, created_at, day, id, lead, meta_data, score, title, updated_at, version, views_distribution")
	} else {
		find.WriteString(strings.Join(r.Columns, ", "))
	}
	find.WriteString(" FROM ")
	find.WriteString(TableNews)
	find.WriteString(" WHERE ")
	find.WriteString(TableNewsColumnID)
	find.WriteString("=")
	find.WritePlaceholder()
	find.Add(pk)
	find.WriteString(" FOR UPDATE")
	query, args, err := r.UpdateOneByIDQuery(pk, p)
	if err != nil {
		return
	}
	var (
		oldEnt, newEnt NewsEntity
	)
	oldProps, err := oldEnt.Props(r.Columns...)
	if err != nil {
		return
	}
	newProps, err := newEnt.Props(r.Columns...)
	if err != nil {
		return
	}
	tx, err := r.DB.Begin()
	if err != nil {
		return
	}
	err = tx.QueryRowContext(ctx, find.String(), find.Args()...).Scan(oldProps...)
	if r.Log != nil {
		r.Log(err, TableNews, "find by primary key", find.String(), find.Args()...)
	}
	if err != nil {
		tx.Rollback()
		return
	}
	err = tx.QueryRowContext(ctx, query, args...).Scan(newProps...)
	if r.Log != nil {
		r.Log(err, TableNews, "update by primary key", query, args...)
	}
	if err != nil {
		tx.Rollback()
		return
	}
	err = tx.Commit()
	if err != nil {
		return
	}
	return &oldEnt, &newEnt, nil
}

func (r *NewsRepositoryBase) UpdateOneByTitleQuery(newsTitle string, p *NewsPatch) (string, []interface{}, error) {
	buf := bytes.NewBufferString("UPDATE ")
	buf.WriteString(r.Table)
	update := NewComposer(1)
	if p.Content.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnContent); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.Content)
		update.Dirty = true

	}
	if p.Continue.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnContinue); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.Continue)
		update.Dirty = true

	}
	if p.CreatedAt.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnCreatedAt); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.CreatedAt)
		update.Dirty = true

	}
	if p.Day.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnDay); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.Day)
		update.Dirty = true

	}
	if p.Lead.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnLead); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.Lead)
		update.Dirty = true

	}
	if p.MetaData != nil {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnMetaData); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.MetaData)
		update.Dirty = true

	}
	if p.Score.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnScore); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.Score)
		update.Dirty = true

	}
	if p.Title.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnTitle); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.Title)
		update.Dirty = true

	}
	if p.UpdatedAt.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnUpdatedAt); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.UpdatedAt)
		update.Dirty = true

	} else {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnUpdatedAt); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("=NOW()"); err != nil {
			return "", nil, err
		}
		update.Dirty = true
	}
	if p.Version.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnVersion); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.Version)
		update.Dirty = true

	} else {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnVersion); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("=version+1"); err != nil {
			return "", nil, err
		}
		update.Dirty = true
	}
	if p.ViewsDistribution.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnViewsDistribution); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.ViewsDistribution)
		update.Dirty = true

	}
	if !update.Dirty {
		return "", nil, errors.New("news update failure, nothing to update")
	}
	buf.WriteString(" SET ")
	buf.ReadFrom(update)
	buf.WriteString(" WHERE ")
	update.WriteString(TableNewsColumnTitle)
	update.WriteString("=")
	update.WritePlaceholder()
	update.Add(newsTitle)
	buf.ReadFrom(update)
	buf.WriteString(" RETURNING ")
	if len(r.Columns) > 0 {
		buf.WriteString(strings.Join(r.Columns, ", "))
	} else {
		buf.WriteString("content, continue, created_at, day, id, lead, meta_data, score, title, updated_at, version, views_distribution")
	}
	return buf.String(), update.Args(), nil
}

func (r *NewsRepositoryBase) UpdateOneByTitleAndLeadQuery(newsTitle string, newsLead string, p *NewsPatch) (string, []interface{}, error) {
	buf := bytes.NewBufferString("UPDATE ")
	buf.WriteString(r.Table)
	update := NewComposer(2)
	if p.Content.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnContent); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.Content)
		update.Dirty = true

	}
	if p.Continue.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnContinue); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.Continue)
		update.Dirty = true

	}
	if p.CreatedAt.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnCreatedAt); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.CreatedAt)
		update.Dirty = true

	}
	if p.Day.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnDay); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.Day)
		update.Dirty = true

	}
	if p.Lead.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnLead); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.Lead)
		update.Dirty = true

	}
	if p.MetaData != nil {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnMetaData); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.MetaData)
		update.Dirty = true

	}
	if p.Score.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnScore); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.Score)
		update.Dirty = true

	}
	if p.Title.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnTitle); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.Title)
		update.Dirty = true

	}
	if p.UpdatedAt.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnUpdatedAt); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.UpdatedAt)
		update.Dirty = true

	} else {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnUpdatedAt); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("=NOW()"); err != nil {
			return "", nil, err
		}
		update.Dirty = true
	}
	if p.Version.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnVersion); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.Version)
		update.Dirty = true

	} else {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnVersion); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("=version+1"); err != nil {
			return "", nil, err
		}
		update.Dirty = true
	}
	if p.ViewsDistribution.Valid {
		if update.Dirty {
			if _, err := update.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := update.WriteString(TableNewsColumnViewsDistribution); err != nil {
			return "", nil, err
		}
		if _, err := update.WriteString("="); err != nil {
			return "", nil, err
		}
		if err := update.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		update.Add(p.ViewsDistribution)
		update.Dirty = true

	}
	if !update.Dirty {
		return "", nil, errors.New("news update failure, nothing to update")
	}
	buf.WriteString(" SET ")
	buf.ReadFrom(update)
	buf.WriteString(" WHERE ")
	update.WriteString(TableNewsColumnTitle)
	update.WriteString("=")
	update.WritePlaceholder()
	update.Add(newsTitle)
	update.WriteString(" AND ")
	update.WriteString(TableNewsColumnLead)
	update.WriteString("=")
	update.WritePlaceholder()
	update.Add(newsLead)
	buf.ReadFrom(update)
	buf.WriteString(" RETURNING ")
	if len(r.Columns) > 0 {
		buf.WriteString(strings.Join(r.Columns, ", "))
	} else {
		buf.WriteString("content, continue, created_at, day, id, lead, meta_data, score, title, updated_at, version, views_distribution")
	}
	return buf.String(), update.Args(), nil
}

func (r *NewsRepositoryBase) UpdateOneByTitle(ctx context.Context, newsTitle string, p *NewsPatch) (*NewsEntity, error) {
	query, args, err := r.UpdateOneByTitleQuery(newsTitle, p)
	if err != nil {
		return nil, err
	}
	var ent NewsEntity
	props, err := ent.Props(r.Columns...)
	if err != nil {
		return nil, err
	}
	err = r.DB.QueryRowContext(ctx, query, args...).Scan(props...)
	if r.Log != nil {
		r.Log(err, TableNews, "update one by unique", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return &ent, nil
}

func (r *NewsRepositoryBase) UpdateOneByTitleAndLead(ctx context.Context, newsTitle string, newsLead string, p *NewsPatch) (*NewsEntity, error) {
	query, args, err := r.UpdateOneByTitleAndLeadQuery(newsTitle, newsLead, p)
	if err != nil {
		return nil, err
	}
	var ent NewsEntity
	props, err := ent.Props(r.Columns...)
	if err != nil {
		return nil, err
	}
	err = r.DB.QueryRowContext(ctx, query, args...).Scan(props...)
	if r.Log != nil {
		r.Log(err, TableNews, "update one by unique", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return &ent, nil
}

func (r *NewsRepositoryBase) UpsertQuery(e *NewsEntity, p *NewsPatch, inf ...string) (string, []interface{}, error) {
	upsert := NewComposer(24)
	columns := bytes.NewBuffer(nil)
	buf := bytes.NewBufferString("INSERT INTO ")
	buf.WriteString(r.Table)

	if columns.Len() > 0 {
		if _, err := columns.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if _, err := columns.WriteString(TableNewsColumnContent); err != nil {
		return "", nil, err
	}
	if upsert.Dirty {
		if _, err := upsert.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if err := upsert.WritePlaceholder(); err != nil {
		return "", nil, err
	}
	upsert.Add(e.Content)
	upsert.Dirty = true

	if columns.Len() > 0 {
		if _, err := columns.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if _, err := columns.WriteString(TableNewsColumnContinue); err != nil {
		return "", nil, err
	}
	if upsert.Dirty {
		if _, err := upsert.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if err := upsert.WritePlaceholder(); err != nil {
		return "", nil, err
	}
	upsert.Add(e.Continue)
	upsert.Dirty = true

	if !e.CreatedAt.IsZero() {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableNewsColumnCreatedAt); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.CreatedAt)
		upsert.Dirty = true
	}

	if e.Day.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableNewsColumnDay); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.Day)
		upsert.Dirty = true
	}

	if e.Lead.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableNewsColumnLead); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.Lead)
		upsert.Dirty = true
	}

	if e.MetaData != nil {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableNewsColumnMetaData); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.MetaData)
		upsert.Dirty = true
	}

	if columns.Len() > 0 {
		if _, err := columns.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if _, err := columns.WriteString(TableNewsColumnScore); err != nil {
		return "", nil, err
	}
	if upsert.Dirty {
		if _, err := upsert.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if err := upsert.WritePlaceholder(); err != nil {
		return "", nil, err
	}
	upsert.Add(e.Score)
	upsert.Dirty = true

	if columns.Len() > 0 {
		if _, err := columns.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if _, err := columns.WriteString(TableNewsColumnTitle); err != nil {
		return "", nil, err
	}
	if upsert.Dirty {
		if _, err := upsert.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if err := upsert.WritePlaceholder(); err != nil {
		return "", nil, err
	}
	upsert.Add(e.Title)
	upsert.Dirty = true

	if e.UpdatedAt.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableNewsColumnUpdatedAt); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.UpdatedAt)
		upsert.Dirty = true
	}

	if columns.Len() > 0 {
		if _, err := columns.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if _, err := columns.WriteString(TableNewsColumnVersion); err != nil {
		return "", nil, err
	}
	if upsert.Dirty {
		if _, err := upsert.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if err := upsert.WritePlaceholder(); err != nil {
		return "", nil, err
	}
	upsert.Add(e.Version)
	upsert.Dirty = true

	if e.ViewsDistribution.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableNewsColumnViewsDistribution); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ViewsDistribution)
		upsert.Dirty = true
	}

	if upsert.Dirty {
		buf.WriteString(" (")
		buf.ReadFrom(columns)
		buf.WriteString(") VALUES (")
		buf.ReadFrom(upsert)
		buf.WriteString(")")
	}
	buf.WriteString(" ON CONFLICT ")
	if len(inf) > 0 {
		upsert.Dirty = false
		if p.Content.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableNewsColumnContent); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.Content)
			upsert.Dirty = true

		}
		if p.Continue.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableNewsColumnContinue); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.Continue)
			upsert.Dirty = true

		}
		if p.CreatedAt.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableNewsColumnCreatedAt); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.CreatedAt)
			upsert.Dirty = true

		}
		if p.Day.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableNewsColumnDay); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.Day)
			upsert.Dirty = true

		}
		if p.Lead.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableNewsColumnLead); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.Lead)
			upsert.Dirty = true

		}
		if p.MetaData != nil {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableNewsColumnMetaData); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.MetaData)
			upsert.Dirty = true

		}
		if p.Score.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableNewsColumnScore); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.Score)
			upsert.Dirty = true

		}
		if p.Title.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableNewsColumnTitle); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.Title)
			upsert.Dirty = true

		}
		if p.UpdatedAt.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableNewsColumnUpdatedAt); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.UpdatedAt)
			upsert.Dirty = true

		} else {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableNewsColumnUpdatedAt); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("=NOW()"); err != nil {
				return "", nil, err
			}
			upsert.Dirty = true
		}
		if p.Version.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableNewsColumnVersion); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.Version)
			upsert.Dirty = true

		} else {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableNewsColumnVersion); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("=version+1"); err != nil {
				return "", nil, err
			}
			upsert.Dirty = true
		}
		if p.ViewsDistribution.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableNewsColumnViewsDistribution); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ViewsDistribution)
			upsert.Dirty = true

		}
	}
	if len(inf) > 0 && upsert.Dirty {
		buf.WriteString("(")
		for j, i := range inf {
			if j != 0 {
				buf.WriteString(", ")
			}
			buf.WriteString(i)
		}
		buf.WriteString(")")
		buf.WriteString(" DO UPDATE SET ")
		buf.ReadFrom(upsert)
	} else {
		buf.WriteString(" DO NOTHING ")
	}
	if upsert.Dirty {
		buf.WriteString(" RETURNING ")
		if len(r.Columns) > 0 {
			buf.WriteString(strings.Join(r.Columns, ", "))
		} else {
			buf.WriteString("content, continue, created_at, day, id, lead, meta_data, score, title, updated_at, version, views_distribution")
		}
	}
	return buf.String(), upsert.Args(), nil
}

func (r *NewsRepositoryBase) Upsert(ctx context.Context, e *NewsEntity, p *NewsPatch, inf ...string) (*NewsEntity, error) {
	query, args, err := r.UpsertQuery(e, p, inf...)
	if err != nil {
		return nil, err
	}
	err = r.DB.QueryRowContext(ctx, query, args...).Scan(
		&e.Content,
		&e.Continue,
		&e.CreatedAt,
		&e.Day,
		&e.ID,
		&e.Lead,
		&e.MetaData,
		&e.Score,
		&e.Title,
		&e.UpdatedAt,
		&e.Version,
		&e.ViewsDistribution,
	)
	if r.Log != nil {
		r.Log(err, TableNews, "upsert", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return e, nil
}

func (r *NewsRepositoryBase) Count(ctx context.Context, c *NewsCountExpr) (int64, error) {
	query, args, err := r.FindQuery(&NewsFindExpr{
		Where:   c.Where,
		Columns: []string{"COUNT(*)"},
	})
	if err != nil {
		return 0, err
	}
	var count int64
	err = r.DB.QueryRowContext(ctx, query, args...).Scan(&count)
	if r.Log != nil {
		r.Log(err, TableNews, "count", query, args...)
	}
	if err != nil {
		return 0, err
	}
	return count, nil
}

func (r *NewsRepositoryBase) DeleteOneByID(ctx context.Context, pk int64) (int64, error) {
	find := NewComposer(12)
	find.WriteString("DELETE FROM ")
	find.WriteString(TableNews)
	find.WriteString(" WHERE ")
	find.WriteString(TableNewsColumnID)
	find.WriteString("=")
	find.WritePlaceholder()
	find.Add(pk)
	res, err := r.DB.ExecContext(ctx, find.String(), find.Args()...)
	if err != nil {
		return 0, err
	}

	return res.RowsAffected()
}

const (
	TableCommentConstraintNewsTitleForeignKey = "example.comment_news_title_fkey"
	TableCommentConstraintNewsTitleIndex      = "example.comment_news_title_idx"
	TableCommentConstraintNewsIDForeignKey    = "example.comment_news_id_fkey"
)

const (
	TableComment                 = "example.comment"
	TableCommentColumnContent    = "content"
	TableCommentColumnCreatedAt  = "created_at"
	TableCommentColumnID         = "id"
	TableCommentColumnIDMultiply = "id_multiply"
	TableCommentColumnNewsID     = "news_id"
	TableCommentColumnNewsTitle  = "news_title"
	TableCommentColumnRightNow   = "right_now"
	TableCommentColumnUpdatedAt  = "updated_at"
)

var TableCommentColumns = []string{
	TableCommentColumnContent,
	TableCommentColumnCreatedAt,
	TableCommentColumnID,
	TableCommentColumnIDMultiply,
	TableCommentColumnNewsID,
	TableCommentColumnNewsTitle,
	TableCommentColumnRightNow,
	TableCommentColumnUpdatedAt,
}

// CommentEntity ...
type CommentEntity struct {
	// Content ...
	Content string
	// CreatedAt ...
	CreatedAt time.Time
	// ID ...
	ID sql.NullInt64
	// IDMultiply ...
	// IDMultiply is read only
	IDMultiply int64
	// NewsID ...
	NewsID int64
	// NewsTitle ...
	NewsTitle string
	// RightNow ...
	// RightNow is read only
	RightNow time.Time
	// UpdatedAt ...
	UpdatedAt pq.NullTime
	// NewsByTitle ...
	NewsByTitle *NewsEntity
	// NewsByID ...
	NewsByID *NewsEntity
}

func (e *CommentEntity) Prop(cn string) (interface{}, bool) {
	switch cn {

	case TableCommentColumnContent:
		return &e.Content, true
	case TableCommentColumnCreatedAt:
		return &e.CreatedAt, true
	case TableCommentColumnID:
		return &e.ID, true
	case TableCommentColumnIDMultiply:
		return &e.IDMultiply, true
	case TableCommentColumnNewsID:
		return &e.NewsID, true
	case TableCommentColumnNewsTitle:
		return &e.NewsTitle, true
	case TableCommentColumnRightNow:
		return &e.RightNow, true
	case TableCommentColumnUpdatedAt:
		return &e.UpdatedAt, true
	default:
		return nil, false
	}
}

func (e *CommentEntity) Props(cns ...string) ([]interface{}, error) {
	if len(cns) == 0 {
		cns = TableCommentColumns
	}
	res := make([]interface{}, 0, len(cns))
	for _, cn := range cns {
		if prop, ok := e.Prop(cn); ok {
			res = append(res, prop)
		} else {
			return nil, fmt.Errorf("unexpected column provided: %s", cn)
		}
	}
	return res, nil
}

// ScanCommentRows helps to scan rows straight to the slice of entities.
func ScanCommentRows(rows Rows) (entities []*CommentEntity, err error) {
	for rows.Next() {
		var ent CommentEntity
		err = rows.Scan(
			&ent.Content,
			&ent.CreatedAt,
			&ent.ID,
			&ent.IDMultiply,
			&ent.NewsID,
			&ent.NewsTitle,
			&ent.RightNow,
			&ent.UpdatedAt,
		)
		if err != nil {
			return
		}

		entities = append(entities, &ent)
	}
	if err = rows.Err(); err != nil {
		return
	}

	return
}

// CommentIterator is not thread safe.
type CommentIterator struct {
	rows Rows
	cols []string
	expr *CommentFindExpr
}

func (i *CommentIterator) Next() bool {
	return i.rows.Next()
}

func (i *CommentIterator) Close() error {
	return i.rows.Close()
}

func (i *CommentIterator) Err() error {
	return i.rows.Err()
}

// Columns is wrapper around sql.Rows.Columns method, that also cache output inside iterator.
func (i *CommentIterator) Columns() ([]string, error) {
	if i.cols == nil {
		cols, err := i.rows.Columns()
		if err != nil {
			return nil, err
		}
		i.cols = cols
	}
	return i.cols, nil
}

// Ent is wrapper around Comment method that makes iterator more generic.
func (i *CommentIterator) Ent() (interface{}, error) {
	return i.Comment()
}

func (i *CommentIterator) Comment() (*CommentEntity, error) {
	var ent CommentEntity
	cols, err := i.Columns()
	if err != nil {
		return nil, err
	}

	props, err := ent.Props(cols...)
	if err != nil {
		return nil, err
	}
	var prop []interface{}
	if i.expr.JoinNewsByTitle != nil && i.expr.JoinNewsByTitle.Kind.Actionable() && i.expr.JoinNewsByTitle.Fetch {
		ent.NewsByTitle = &NewsEntity{}
		if prop, err = ent.NewsByTitle.Props(); err != nil {
			return nil, err
		}
		props = append(props, prop...)
	}
	if i.expr.JoinNewsByID != nil && i.expr.JoinNewsByID.Kind.Actionable() && i.expr.JoinNewsByID.Fetch {
		ent.NewsByID = &NewsEntity{}
		if prop, err = ent.NewsByID.Props(); err != nil {
			return nil, err
		}
		props = append(props, prop...)
	}
	if err := i.rows.Scan(props...); err != nil {
		return nil, err
	}
	return &ent, nil
}

type CommentCriteria struct {
	Content                sql.NullString
	CreatedAt              pq.NullTime
	ID                     sql.NullInt64
	IDMultiply             sql.NullInt64
	NewsID                 sql.NullInt64
	NewsTitle              sql.NullString
	RightNow               pq.NullTime
	UpdatedAt              pq.NullTime
	operator               string
	child, sibling, parent *CommentCriteria
}

func CommentOperand(operator string, operands ...*CommentCriteria) *CommentCriteria {
	if len(operands) == 0 {
		return &CommentCriteria{operator: operator}
	}

	parent := &CommentCriteria{
		operator: operator,
		child:    operands[0],
	}

	for i := 0; i < len(operands); i++ {
		if i < len(operands)-1 {
			operands[i].sibling = operands[i+1]
		}
		operands[i].parent = parent
	}

	return parent
}

func CommentOr(operands ...*CommentCriteria) *CommentCriteria {
	return CommentOperand("OR", operands...)
}

func CommentAnd(operands ...*CommentCriteria) *CommentCriteria {
	return CommentOperand("AND", operands...)
}

type CommentFindExpr struct {
	Where           *CommentCriteria
	Offset, Limit   int64
	Columns         []string
	OrderBy         []RowOrder
	JoinNewsByTitle *NewsJoin
	JoinNewsByID    *NewsJoin
}

type CommentJoin struct {
	On, Where       *CommentCriteria
	Fetch           bool
	Kind            JoinType
	JoinNewsByTitle *NewsJoin
	JoinNewsByID    *NewsJoin
}

type CommentCountExpr struct {
	Where           *CommentCriteria
	JoinNewsByTitle *NewsJoin
	JoinNewsByID    *NewsJoin
}

type CommentPatch struct {
	Content    sql.NullString
	CreatedAt  pq.NullTime
	ID         sql.NullInt64
	IDMultiply sql.NullInt64
	NewsID     sql.NullInt64
	NewsTitle  sql.NullString
	RightNow   pq.NullTime
	UpdatedAt  pq.NullTime
}

type CommentRepositoryBase struct {
	Table   string
	Columns []string
	DB      *sql.DB
	Log     LogFunc
}

func (r *CommentRepositoryBase) InsertQuery(e *CommentEntity, read bool) (string, []interface{}, error) {
	insert := NewComposer(8)
	columns := bytes.NewBuffer(nil)
	buf := bytes.NewBufferString("INSERT INTO ")
	buf.WriteString(r.Table)

	if columns.Len() > 0 {
		if _, err := columns.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if _, err := columns.WriteString(TableCommentColumnContent); err != nil {
		return "", nil, err
	}
	if insert.Dirty {
		if _, err := insert.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if err := insert.WritePlaceholder(); err != nil {
		return "", nil, err
	}
	insert.Add(e.Content)
	insert.Dirty = true

	if !e.CreatedAt.IsZero() {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCommentColumnCreatedAt); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.CreatedAt)
		insert.Dirty = true
	}

	if columns.Len() > 0 {
		if _, err := columns.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if _, err := columns.WriteString(TableCommentColumnNewsID); err != nil {
		return "", nil, err
	}
	if insert.Dirty {
		if _, err := insert.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if err := insert.WritePlaceholder(); err != nil {
		return "", nil, err
	}
	insert.Add(e.NewsID)
	insert.Dirty = true

	if columns.Len() > 0 {
		if _, err := columns.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if _, err := columns.WriteString(TableCommentColumnNewsTitle); err != nil {
		return "", nil, err
	}
	if insert.Dirty {
		if _, err := insert.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if err := insert.WritePlaceholder(); err != nil {
		return "", nil, err
	}
	insert.Add(e.NewsTitle)
	insert.Dirty = true

	if e.UpdatedAt.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCommentColumnUpdatedAt); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.UpdatedAt)
		insert.Dirty = true
	}

	if columns.Len() > 0 {
		buf.WriteString(" (")
		buf.ReadFrom(columns)
		buf.WriteString(") VALUES (")
		buf.ReadFrom(insert)
		buf.WriteString(") ")
		if read {
			buf.WriteString("RETURNING ")
			if len(r.Columns) > 0 {
				buf.WriteString(strings.Join(r.Columns, ", "))
			} else {
				buf.WriteString("content, created_at, id, multiply(id, id) AS id_multiply, news_id, news_title, now() AS right_now, updated_at")
			}
		}
	}
	return buf.String(), insert.Args(), nil
}

func (r *CommentRepositoryBase) Insert(ctx context.Context, e *CommentEntity) (*CommentEntity, error) {
	query, args, err := r.InsertQuery(e, true)
	if err != nil {
		return nil, err
	}
	err = r.DB.QueryRowContext(ctx, query, args...).Scan(
		&e.Content,
		&e.CreatedAt,
		&e.ID,
		&e.IDMultiply,
		&e.NewsID,
		&e.NewsTitle,
		&e.RightNow,
		&e.UpdatedAt,
	)
	if r.Log != nil {
		r.Log(err, TableComment, "insert", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return e, nil
}

func CommentCriteriaWhereClause(comp *Composer, c *CommentCriteria, id int) error {
	if c.child == nil {
		return _CommentCriteriaWhereClause(comp, c, id)
	}
	node := c
	sibling := false
	for {
		if !sibling {
			if node.child != nil {
				if node.parent != nil {
					comp.WriteString("(")
				}
				node = node.child
				continue
			} else {
				comp.Dirty = false
				comp.WriteString("(")
				if err := _CommentCriteriaWhereClause(comp, node, id); err != nil {
					return err
				}
				comp.WriteString(")")
			}
		}
		if node.sibling != nil {
			sibling = false
			comp.WriteString(" ")
			comp.WriteString(node.parent.operator)
			comp.WriteString(" ")
			node = node.sibling
			continue
		}
		if node.parent != nil {
			sibling = true
			if node.parent.parent != nil {
				comp.WriteString(")")
			}
			node = node.parent
			continue
		}

		break
	}
	return nil
}

func _CommentCriteriaWhereClause(comp *Composer, c *CommentCriteria, id int) error {
	if c.Content.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCommentColumnContent); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.Content)
		comp.Dirty = true
	}
	if c.CreatedAt.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCommentColumnCreatedAt); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.CreatedAt)
		comp.Dirty = true
	}
	// id is an empty struct, ignore

	if c.IDMultiply.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if _, err := comp.WriteString("multiply"); err != nil {
			return err
		}
		if _, err := comp.WriteString("("); err != nil {
			return err
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCommentColumnID); err != nil {
			return err
		}
		if _, err := comp.WriteString(", "); err != nil {
			return err
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCommentColumnID); err != nil {
			return err
		}
		if _, err := comp.WriteString(")"); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.IDMultiply)
		comp.Dirty = true
	}
	if c.NewsID.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCommentColumnNewsID); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.NewsID)
		comp.Dirty = true
	}
	if c.NewsTitle.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCommentColumnNewsTitle); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.NewsTitle)
		comp.Dirty = true
	}
	if c.RightNow.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if _, err := comp.WriteString("now"); err != nil {
			return err
		}
		if _, err := comp.WriteString("("); err != nil {
			return err
		}
		if _, err := comp.WriteString(")"); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.RightNow)
		comp.Dirty = true
	}
	if c.UpdatedAt.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCommentColumnUpdatedAt); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.UpdatedAt)
		comp.Dirty = true
	}
	return nil
}

func (r *CommentRepositoryBase) FindQuery(fe *CommentFindExpr) (string, []interface{}, error) {
	comp := NewComposer(8)
	buf := bytes.NewBufferString("SELECT ")
	if len(fe.Columns) == 0 {
		buf.WriteString("t0.content, t0.created_at, t0.id, multiply(t0.id, t0.id) AS id_multiply, t0.news_id, t0.news_title, now() AS right_now, t0.updated_at")
	} else {
		buf.WriteString(strings.Join(fe.Columns, ", "))
	}
	if fe.JoinNewsByTitle != nil && fe.JoinNewsByTitle.Kind.Actionable() && fe.JoinNewsByTitle.Fetch {
		buf.WriteString(", t1.content, t1.continue, t1.created_at, t1.day, t1.id, t1.lead, t1.meta_data, t1.score, t1.title, t1.updated_at, t1.version, t1.views_distribution")
	}
	if fe.JoinNewsByID != nil && fe.JoinNewsByID.Kind.Actionable() && fe.JoinNewsByID.Fetch {
		buf.WriteString(", t2.content, t2.continue, t2.created_at, t2.day, t2.id, t2.lead, t2.meta_data, t2.score, t2.title, t2.updated_at, t2.version, t2.views_distribution")
	}
	buf.WriteString(" FROM ")
	buf.WriteString(r.Table)
	buf.WriteString(" AS t0")
	if fe.JoinNewsByTitle != nil && fe.JoinNewsByTitle.Kind.Actionable() {
		joinClause(comp, fe.JoinNewsByTitle.Kind, "example.news AS t1 ON t0.news_title=t1.title")
		if fe.JoinNewsByTitle.On != nil {
			comp.Dirty = true
			if err := NewsCriteriaWhereClause(comp, fe.JoinNewsByTitle.On, 1); err != nil {
				return "", nil, err
			}
		}
	}
	if fe.JoinNewsByID != nil && fe.JoinNewsByID.Kind.Actionable() {
		joinClause(comp, fe.JoinNewsByID.Kind, "example.news AS t2 ON t0.news_id=t2.id")
		if fe.JoinNewsByID.On != nil {
			comp.Dirty = true
			if err := NewsCriteriaWhereClause(comp, fe.JoinNewsByID.On, 2); err != nil {
				return "", nil, err
			}
		}
	}
	if comp.Dirty {
		buf.ReadFrom(comp)
		comp.Dirty = false
	}
	if fe.Where != nil {
		if err := CommentCriteriaWhereClause(comp, fe.Where, 0); err != nil {
			return "", nil, err
		}
	}
	if fe.JoinNewsByTitle != nil && fe.JoinNewsByTitle.Kind.Actionable() && fe.JoinNewsByTitle.Where != nil {
		if err := NewsCriteriaWhereClause(comp, fe.JoinNewsByTitle.Where, 1); err != nil {
			return "", nil, err
		}
	}
	if fe.JoinNewsByID != nil && fe.JoinNewsByID.Kind.Actionable() && fe.JoinNewsByID.Where != nil {
		if err := NewsCriteriaWhereClause(comp, fe.JoinNewsByID.Where, 2); err != nil {
			return "", nil, err
		}
	}
	if comp.Dirty {
		if _, err := buf.WriteString(" WHERE "); err != nil {
			return "", nil, err
		}
		buf.ReadFrom(comp)
	}

	if len(fe.OrderBy) > 0 {
		i := 0
		for _, order := range fe.OrderBy {
			for _, columnName := range TableCommentColumns {
				if order.Name == columnName {
					if i == 0 {
						comp.WriteString(" ORDER BY ")
					}
					if i > 0 {
						if _, err := comp.WriteString(", "); err != nil {
							return "", nil, err
						}
					}
					if _, err := comp.WriteString(order.Name); err != nil {
						return "", nil, err
					}
					if order.Descending {
						if _, err := comp.WriteString(" DESC"); err != nil {
							return "", nil, err
						}
					}
					i++
					break
				}
			}
		}
	}
	if fe.Offset > 0 {
		if _, err := comp.WriteString(" OFFSET "); err != nil {
			return "", nil, err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		if _, err := comp.WriteString(" "); err != nil {
			return "", nil, err
		}
		comp.Add(fe.Offset)
	}
	if fe.Limit > 0 {
		if _, err := comp.WriteString(" LIMIT "); err != nil {
			return "", nil, err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		if _, err := comp.WriteString(" "); err != nil {
			return "", nil, err
		}
		comp.Add(fe.Limit)
	}

	buf.ReadFrom(comp)

	return buf.String(), comp.Args(), nil
}

func (r *CommentRepositoryBase) Find(ctx context.Context, fe *CommentFindExpr) ([]*CommentEntity, error) {
	query, args, err := r.FindQuery(fe)
	if err != nil {
		return nil, err
	}
	rows, err := r.DB.QueryContext(ctx, query, args...)
	if r.Log != nil {
		r.Log(err, TableComment, "find", query, args...)
	}
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var (
		entities []*CommentEntity
		props    []interface{}
	)
	for rows.Next() {
		var ent CommentEntity
		if props, err = ent.Props(); err != nil {
			return nil, err
		}
		var prop []interface{}
		if fe.JoinNewsByTitle != nil && fe.JoinNewsByTitle.Kind.Actionable() && fe.JoinNewsByTitle.Fetch {
			ent.NewsByTitle = &NewsEntity{}
			if prop, err = ent.NewsByTitle.Props(); err != nil {
				return nil, err
			}
			props = append(props, prop...)
		}
		if fe.JoinNewsByID != nil && fe.JoinNewsByID.Kind.Actionable() && fe.JoinNewsByID.Fetch {
			ent.NewsByID = &NewsEntity{}
			if prop, err = ent.NewsByID.Props(); err != nil {
				return nil, err
			}
			props = append(props, prop...)
		}
		err = rows.Scan(props...)
		if err != nil {
			return nil, err
		}

		entities = append(entities, &ent)
	}
	err = rows.Err()
	if r.Log != nil {
		r.Log(err, TableComment, "find", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return entities, nil
}

func (r *CommentRepositoryBase) FindIter(ctx context.Context, fe *CommentFindExpr) (*CommentIterator, error) {
	query, args, err := r.FindQuery(fe)
	if err != nil {
		return nil, err
	}
	rows, err := r.DB.QueryContext(ctx, query, args...)
	if r.Log != nil {
		r.Log(err, TableComment, "find iter", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return &CommentIterator{
		rows: rows,
		expr: fe,
		cols: fe.Columns,
	}, nil
}

func (r *CommentRepositoryBase) UpsertQuery(e *CommentEntity, p *CommentPatch, inf ...string) (string, []interface{}, error) {
	upsert := NewComposer(16)
	columns := bytes.NewBuffer(nil)
	buf := bytes.NewBufferString("INSERT INTO ")
	buf.WriteString(r.Table)

	if columns.Len() > 0 {
		if _, err := columns.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if _, err := columns.WriteString(TableCommentColumnContent); err != nil {
		return "", nil, err
	}
	if upsert.Dirty {
		if _, err := upsert.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if err := upsert.WritePlaceholder(); err != nil {
		return "", nil, err
	}
	upsert.Add(e.Content)
	upsert.Dirty = true

	if !e.CreatedAt.IsZero() {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCommentColumnCreatedAt); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.CreatedAt)
		upsert.Dirty = true
	}

	if columns.Len() > 0 {
		if _, err := columns.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if _, err := columns.WriteString(TableCommentColumnNewsID); err != nil {
		return "", nil, err
	}
	if upsert.Dirty {
		if _, err := upsert.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if err := upsert.WritePlaceholder(); err != nil {
		return "", nil, err
	}
	upsert.Add(e.NewsID)
	upsert.Dirty = true

	if columns.Len() > 0 {
		if _, err := columns.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if _, err := columns.WriteString(TableCommentColumnNewsTitle); err != nil {
		return "", nil, err
	}
	if upsert.Dirty {
		if _, err := upsert.WriteString(", "); err != nil {
			return "", nil, err
		}
	}
	if err := upsert.WritePlaceholder(); err != nil {
		return "", nil, err
	}
	upsert.Add(e.NewsTitle)
	upsert.Dirty = true

	if e.UpdatedAt.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCommentColumnUpdatedAt); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.UpdatedAt)
		upsert.Dirty = true
	}

	if upsert.Dirty {
		buf.WriteString(" (")
		buf.ReadFrom(columns)
		buf.WriteString(") VALUES (")
		buf.ReadFrom(upsert)
		buf.WriteString(")")
	}
	buf.WriteString(" ON CONFLICT ")
	if len(inf) > 0 {
		upsert.Dirty = false
		if p.Content.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCommentColumnContent); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.Content)
			upsert.Dirty = true

		}
		if p.CreatedAt.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCommentColumnCreatedAt); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.CreatedAt)
			upsert.Dirty = true

		}
		if p.ID.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCommentColumnID); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ID)
			upsert.Dirty = true

		}
		if p.NewsID.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCommentColumnNewsID); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.NewsID)
			upsert.Dirty = true

		}
		if p.NewsTitle.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCommentColumnNewsTitle); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.NewsTitle)
			upsert.Dirty = true

		}
		if p.UpdatedAt.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCommentColumnUpdatedAt); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.UpdatedAt)
			upsert.Dirty = true

		} else {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCommentColumnUpdatedAt); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("=NOW()"); err != nil {
				return "", nil, err
			}
			upsert.Dirty = true
		}
	}
	if len(inf) > 0 && upsert.Dirty {
		buf.WriteString("(")
		for j, i := range inf {
			if j != 0 {
				buf.WriteString(", ")
			}
			buf.WriteString(i)
		}
		buf.WriteString(")")
		buf.WriteString(" DO UPDATE SET ")
		buf.ReadFrom(upsert)
	} else {
		buf.WriteString(" DO NOTHING ")
	}
	if upsert.Dirty {
		buf.WriteString(" RETURNING ")
		if len(r.Columns) > 0 {
			buf.WriteString(strings.Join(r.Columns, ", "))
		} else {
			buf.WriteString("content, created_at, id, multiply(id, id) AS id_multiply, news_id, news_title, now() AS right_now, updated_at")
		}
	}
	return buf.String(), upsert.Args(), nil
}

func (r *CommentRepositoryBase) Upsert(ctx context.Context, e *CommentEntity, p *CommentPatch, inf ...string) (*CommentEntity, error) {
	query, args, err := r.UpsertQuery(e, p, inf...)
	if err != nil {
		return nil, err
	}
	err = r.DB.QueryRowContext(ctx, query, args...).Scan(
		&e.Content,
		&e.CreatedAt,
		&e.ID,
		&e.IDMultiply,
		&e.NewsID,
		&e.NewsTitle,
		&e.RightNow,
		&e.UpdatedAt,
	)
	if r.Log != nil {
		r.Log(err, TableComment, "upsert", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return e, nil
}

func (r *CommentRepositoryBase) Count(ctx context.Context, c *CommentCountExpr) (int64, error) {
	query, args, err := r.FindQuery(&CommentFindExpr{
		Where:   c.Where,
		Columns: []string{"COUNT(*)"},

		JoinNewsByTitle: c.JoinNewsByTitle,
		JoinNewsByID:    c.JoinNewsByID,
	})
	if err != nil {
		return 0, err
	}
	var count int64
	err = r.DB.QueryRowContext(ctx, query, args...).Scan(&count)
	if r.Log != nil {
		r.Log(err, TableComment, "count", query, args...)
	}
	if err != nil {
		return 0, err
	}
	return count, nil
}

const ()

const (
	TableComplete                                 = "example.complete"
	TableCompleteColumnColumnBool                 = "column_bool"
	TableCompleteColumnColumnBytea                = "column_bytea"
	TableCompleteColumnColumnCharacter0           = "column_character_0"
	TableCompleteColumnColumnCharacter100         = "column_character_100"
	TableCompleteColumnColumnDecimal              = "column_decimal"
	TableCompleteColumnColumnDoubleArray0         = "column_double_array_0"
	TableCompleteColumnColumnDoubleArray100       = "column_double_array_100"
	TableCompleteColumnColumnInteger              = "column_integer"
	TableCompleteColumnColumnIntegerArray0        = "column_integer_array_0"
	TableCompleteColumnColumnIntegerArray100      = "column_integer_array_100"
	TableCompleteColumnColumnIntegerBig           = "column_integer_big"
	TableCompleteColumnColumnIntegerBigArray0     = "column_integer_big_array_0"
	TableCompleteColumnColumnIntegerBigArray100   = "column_integer_big_array_100"
	TableCompleteColumnColumnIntegerSmall         = "column_integer_small"
	TableCompleteColumnColumnIntegerSmallArray0   = "column_integer_small_array_0"
	TableCompleteColumnColumnIntegerSmallArray100 = "column_integer_small_array_100"
	TableCompleteColumnColumnJson                 = "column_json"
	TableCompleteColumnColumnJsonNn               = "column_json_nn"
	TableCompleteColumnColumnJsonNnD              = "column_json_nn_d"
	TableCompleteColumnColumnJsonb                = "column_jsonb"
	TableCompleteColumnColumnJsonbNn              = "column_jsonb_nn"
	TableCompleteColumnColumnJsonbNnD             = "column_jsonb_nn_d"
	TableCompleteColumnColumnNumeric              = "column_numeric"
	TableCompleteColumnColumnReal                 = "column_real"
	TableCompleteColumnColumnSerial               = "column_serial"
	TableCompleteColumnColumnSerialBig            = "column_serial_big"
	TableCompleteColumnColumnSerialSmall          = "column_serial_small"
	TableCompleteColumnColumnText                 = "column_text"
	TableCompleteColumnColumnTextArray0           = "column_text_array_0"
	TableCompleteColumnColumnTextArray100         = "column_text_array_100"
	TableCompleteColumnColumnTimestamp            = "column_timestamp"
	TableCompleteColumnColumnTimestamptz          = "column_timestamptz"
	TableCompleteColumnColumnUUID                 = "column_uuid"
)

var TableCompleteColumns = []string{
	TableCompleteColumnColumnBool,
	TableCompleteColumnColumnBytea,
	TableCompleteColumnColumnCharacter0,
	TableCompleteColumnColumnCharacter100,
	TableCompleteColumnColumnDecimal,
	TableCompleteColumnColumnDoubleArray0,
	TableCompleteColumnColumnDoubleArray100,
	TableCompleteColumnColumnInteger,
	TableCompleteColumnColumnIntegerArray0,
	TableCompleteColumnColumnIntegerArray100,
	TableCompleteColumnColumnIntegerBig,
	TableCompleteColumnColumnIntegerBigArray0,
	TableCompleteColumnColumnIntegerBigArray100,
	TableCompleteColumnColumnIntegerSmall,
	TableCompleteColumnColumnIntegerSmallArray0,
	TableCompleteColumnColumnIntegerSmallArray100,
	TableCompleteColumnColumnJson,
	TableCompleteColumnColumnJsonNn,
	TableCompleteColumnColumnJsonNnD,
	TableCompleteColumnColumnJsonb,
	TableCompleteColumnColumnJsonbNn,
	TableCompleteColumnColumnJsonbNnD,
	TableCompleteColumnColumnNumeric,
	TableCompleteColumnColumnReal,
	TableCompleteColumnColumnSerial,
	TableCompleteColumnColumnSerialBig,
	TableCompleteColumnColumnSerialSmall,
	TableCompleteColumnColumnText,
	TableCompleteColumnColumnTextArray0,
	TableCompleteColumnColumnTextArray100,
	TableCompleteColumnColumnTimestamp,
	TableCompleteColumnColumnTimestamptz,
	TableCompleteColumnColumnUUID,
}

// CompleteEntity ...
type CompleteEntity struct {
	// ColumnBool ...
	ColumnBool sql.NullBool
	// ColumnBytea ...
	ColumnBytea []byte
	// ColumnCharacter0 ...
	ColumnCharacter0 sql.NullString
	// ColumnCharacter100 ...
	ColumnCharacter100 sql.NullString
	// ColumnDecimal ...
	ColumnDecimal sql.NullFloat64
	// ColumnDoubleArray0 ...
	ColumnDoubleArray0 NullFloat64Array
	// ColumnDoubleArray100 ...
	ColumnDoubleArray100 NullFloat64Array
	// ColumnInteger ...
	ColumnInteger *int32
	// ColumnIntegerArray0 ...
	ColumnIntegerArray0 NullInt64Array
	// ColumnIntegerArray100 ...
	ColumnIntegerArray100 NullInt64Array
	// ColumnIntegerBig ...
	ColumnIntegerBig sql.NullInt64
	// ColumnIntegerBigArray0 ...
	ColumnIntegerBigArray0 NullInt64Array
	// ColumnIntegerBigArray100 ...
	ColumnIntegerBigArray100 NullInt64Array
	// ColumnIntegerSmall ...
	ColumnIntegerSmall *int16
	// ColumnIntegerSmallArray0 ...
	ColumnIntegerSmallArray0 NullInt64Array
	// ColumnIntegerSmallArray100 ...
	ColumnIntegerSmallArray100 NullInt64Array
	// ColumnJson ...
	ColumnJson []byte
	// ColumnJsonNn ...
	ColumnJsonNn []byte
	// ColumnJsonNnD ...
	ColumnJsonNnD []byte
	// ColumnJsonb ...
	ColumnJsonb []byte
	// ColumnJsonbNn ...
	ColumnJsonbNn []byte
	// ColumnJsonbNnD ...
	ColumnJsonbNnD []byte
	// ColumnNumeric ...
	ColumnNumeric sql.NullFloat64
	// ColumnReal ...
	ColumnReal *float32
	// ColumnSerial ...
	ColumnSerial *int32
	// ColumnSerialBig ...
	ColumnSerialBig sql.NullInt64
	// ColumnSerialSmall ...
	ColumnSerialSmall *int16
	// ColumnText ...
	ColumnText sql.NullString
	// ColumnTextArray0 ...
	ColumnTextArray0 NullStringArray
	// ColumnTextArray100 ...
	ColumnTextArray100 NullStringArray
	// ColumnTimestamp ...
	ColumnTimestamp pq.NullTime
	// ColumnTimestamptz ...
	ColumnTimestamptz pq.NullTime
	// ColumnUUID ...
	ColumnUUID sql.NullString
}

func (e *CompleteEntity) Prop(cn string) (interface{}, bool) {
	switch cn {

	case TableCompleteColumnColumnBool:
		return &e.ColumnBool, true
	case TableCompleteColumnColumnBytea:
		return &e.ColumnBytea, true
	case TableCompleteColumnColumnCharacter0:
		return &e.ColumnCharacter0, true
	case TableCompleteColumnColumnCharacter100:
		return &e.ColumnCharacter100, true
	case TableCompleteColumnColumnDecimal:
		return &e.ColumnDecimal, true
	case TableCompleteColumnColumnDoubleArray0:
		return &e.ColumnDoubleArray0, true
	case TableCompleteColumnColumnDoubleArray100:
		return &e.ColumnDoubleArray100, true
	case TableCompleteColumnColumnInteger:
		return e.ColumnInteger, true
	case TableCompleteColumnColumnIntegerArray0:
		return &e.ColumnIntegerArray0, true
	case TableCompleteColumnColumnIntegerArray100:
		return &e.ColumnIntegerArray100, true
	case TableCompleteColumnColumnIntegerBig:
		return &e.ColumnIntegerBig, true
	case TableCompleteColumnColumnIntegerBigArray0:
		return &e.ColumnIntegerBigArray0, true
	case TableCompleteColumnColumnIntegerBigArray100:
		return &e.ColumnIntegerBigArray100, true
	case TableCompleteColumnColumnIntegerSmall:
		return e.ColumnIntegerSmall, true
	case TableCompleteColumnColumnIntegerSmallArray0:
		return &e.ColumnIntegerSmallArray0, true
	case TableCompleteColumnColumnIntegerSmallArray100:
		return &e.ColumnIntegerSmallArray100, true
	case TableCompleteColumnColumnJson:
		return &e.ColumnJson, true
	case TableCompleteColumnColumnJsonNn:
		return &e.ColumnJsonNn, true
	case TableCompleteColumnColumnJsonNnD:
		return &e.ColumnJsonNnD, true
	case TableCompleteColumnColumnJsonb:
		return &e.ColumnJsonb, true
	case TableCompleteColumnColumnJsonbNn:
		return &e.ColumnJsonbNn, true
	case TableCompleteColumnColumnJsonbNnD:
		return &e.ColumnJsonbNnD, true
	case TableCompleteColumnColumnNumeric:
		return &e.ColumnNumeric, true
	case TableCompleteColumnColumnReal:
		return e.ColumnReal, true
	case TableCompleteColumnColumnSerial:
		return e.ColumnSerial, true
	case TableCompleteColumnColumnSerialBig:
		return &e.ColumnSerialBig, true
	case TableCompleteColumnColumnSerialSmall:
		return e.ColumnSerialSmall, true
	case TableCompleteColumnColumnText:
		return &e.ColumnText, true
	case TableCompleteColumnColumnTextArray0:
		return &e.ColumnTextArray0, true
	case TableCompleteColumnColumnTextArray100:
		return &e.ColumnTextArray100, true
	case TableCompleteColumnColumnTimestamp:
		return &e.ColumnTimestamp, true
	case TableCompleteColumnColumnTimestamptz:
		return &e.ColumnTimestamptz, true
	case TableCompleteColumnColumnUUID:
		return &e.ColumnUUID, true
	default:
		return nil, false
	}
}

func (e *CompleteEntity) Props(cns ...string) ([]interface{}, error) {
	if len(cns) == 0 {
		cns = TableCompleteColumns
	}
	res := make([]interface{}, 0, len(cns))
	for _, cn := range cns {
		if prop, ok := e.Prop(cn); ok {
			res = append(res, prop)
		} else {
			return nil, fmt.Errorf("unexpected column provided: %s", cn)
		}
	}
	return res, nil
}

// ScanCompleteRows helps to scan rows straight to the slice of entities.
func ScanCompleteRows(rows Rows) (entities []*CompleteEntity, err error) {
	for rows.Next() {
		var ent CompleteEntity
		err = rows.Scan(
			&ent.ColumnBool,
			&ent.ColumnBytea,
			&ent.ColumnCharacter0,
			&ent.ColumnCharacter100,
			&ent.ColumnDecimal,
			&ent.ColumnDoubleArray0,
			&ent.ColumnDoubleArray100,
			&ent.ColumnInteger,
			&ent.ColumnIntegerArray0,
			&ent.ColumnIntegerArray100,
			&ent.ColumnIntegerBig,
			&ent.ColumnIntegerBigArray0,
			&ent.ColumnIntegerBigArray100,
			&ent.ColumnIntegerSmall,
			&ent.ColumnIntegerSmallArray0,
			&ent.ColumnIntegerSmallArray100,
			&ent.ColumnJson,
			&ent.ColumnJsonNn,
			&ent.ColumnJsonNnD,
			&ent.ColumnJsonb,
			&ent.ColumnJsonbNn,
			&ent.ColumnJsonbNnD,
			&ent.ColumnNumeric,
			&ent.ColumnReal,
			&ent.ColumnSerial,
			&ent.ColumnSerialBig,
			&ent.ColumnSerialSmall,
			&ent.ColumnText,
			&ent.ColumnTextArray0,
			&ent.ColumnTextArray100,
			&ent.ColumnTimestamp,
			&ent.ColumnTimestamptz,
			&ent.ColumnUUID,
		)
		if err != nil {
			return
		}

		entities = append(entities, &ent)
	}
	if err = rows.Err(); err != nil {
		return
	}

	return
}

// CompleteIterator is not thread safe.
type CompleteIterator struct {
	rows Rows
	cols []string
	expr *CompleteFindExpr
}

func (i *CompleteIterator) Next() bool {
	return i.rows.Next()
}

func (i *CompleteIterator) Close() error {
	return i.rows.Close()
}

func (i *CompleteIterator) Err() error {
	return i.rows.Err()
}

// Columns is wrapper around sql.Rows.Columns method, that also cache output inside iterator.
func (i *CompleteIterator) Columns() ([]string, error) {
	if i.cols == nil {
		cols, err := i.rows.Columns()
		if err != nil {
			return nil, err
		}
		i.cols = cols
	}
	return i.cols, nil
}

// Ent is wrapper around Complete method that makes iterator more generic.
func (i *CompleteIterator) Ent() (interface{}, error) {
	return i.Complete()
}

func (i *CompleteIterator) Complete() (*CompleteEntity, error) {
	var ent CompleteEntity
	cols, err := i.Columns()
	if err != nil {
		return nil, err
	}

	props, err := ent.Props(cols...)
	if err != nil {
		return nil, err
	}
	if err := i.rows.Scan(props...); err != nil {
		return nil, err
	}
	return &ent, nil
}

type CompleteCriteria struct {
	ColumnBool                 sql.NullBool
	ColumnBytea                []byte
	ColumnCharacter0           sql.NullString
	ColumnCharacter100         sql.NullString
	ColumnDecimal              sql.NullFloat64
	ColumnDoubleArray0         NullFloat64Array
	ColumnDoubleArray100       NullFloat64Array
	ColumnInteger              *int32
	ColumnIntegerArray0        NullInt64Array
	ColumnIntegerArray100      NullInt64Array
	ColumnIntegerBig           sql.NullInt64
	ColumnIntegerBigArray0     NullInt64Array
	ColumnIntegerBigArray100   NullInt64Array
	ColumnIntegerSmall         *int16
	ColumnIntegerSmallArray0   NullInt64Array
	ColumnIntegerSmallArray100 NullInt64Array
	ColumnJson                 []byte
	ColumnJsonNn               []byte
	ColumnJsonNnD              []byte
	ColumnJsonb                []byte
	ColumnJsonbNn              []byte
	ColumnJsonbNnD             []byte
	ColumnNumeric              sql.NullFloat64
	ColumnReal                 *float32
	ColumnSerial               *int32
	ColumnSerialBig            sql.NullInt64
	ColumnSerialSmall          *int16
	ColumnText                 sql.NullString
	ColumnTextArray0           NullStringArray
	ColumnTextArray100         NullStringArray
	ColumnTimestamp            pq.NullTime
	ColumnTimestamptz          pq.NullTime
	ColumnUUID                 sql.NullString
	operator                   string
	child, sibling, parent     *CompleteCriteria
}

func CompleteOperand(operator string, operands ...*CompleteCriteria) *CompleteCriteria {
	if len(operands) == 0 {
		return &CompleteCriteria{operator: operator}
	}

	parent := &CompleteCriteria{
		operator: operator,
		child:    operands[0],
	}

	for i := 0; i < len(operands); i++ {
		if i < len(operands)-1 {
			operands[i].sibling = operands[i+1]
		}
		operands[i].parent = parent
	}

	return parent
}

func CompleteOr(operands ...*CompleteCriteria) *CompleteCriteria {
	return CompleteOperand("OR", operands...)
}

func CompleteAnd(operands ...*CompleteCriteria) *CompleteCriteria {
	return CompleteOperand("AND", operands...)
}

type CompleteFindExpr struct {
	Where         *CompleteCriteria
	Offset, Limit int64
	Columns       []string
	OrderBy       []RowOrder
}

type CompleteJoin struct {
	On, Where *CompleteCriteria
	Fetch     bool
	Kind      JoinType
}

type CompleteCountExpr struct {
	Where *CompleteCriteria
}

type CompletePatch struct {
	ColumnBool                 sql.NullBool
	ColumnBytea                []byte
	ColumnCharacter0           sql.NullString
	ColumnCharacter100         sql.NullString
	ColumnDecimal              sql.NullFloat64
	ColumnDoubleArray0         NullFloat64Array
	ColumnDoubleArray100       NullFloat64Array
	ColumnInteger              *int32
	ColumnIntegerArray0        NullInt64Array
	ColumnIntegerArray100      NullInt64Array
	ColumnIntegerBig           sql.NullInt64
	ColumnIntegerBigArray0     NullInt64Array
	ColumnIntegerBigArray100   NullInt64Array
	ColumnIntegerSmall         *int16
	ColumnIntegerSmallArray0   NullInt64Array
	ColumnIntegerSmallArray100 NullInt64Array
	ColumnJson                 []byte
	ColumnJsonNn               []byte
	ColumnJsonNnD              []byte
	ColumnJsonb                []byte
	ColumnJsonbNn              []byte
	ColumnJsonbNnD             []byte
	ColumnNumeric              sql.NullFloat64
	ColumnReal                 *float32
	ColumnSerial               *int32
	ColumnSerialBig            sql.NullInt64
	ColumnSerialSmall          *int16
	ColumnText                 sql.NullString
	ColumnTextArray0           NullStringArray
	ColumnTextArray100         NullStringArray
	ColumnTimestamp            pq.NullTime
	ColumnTimestamptz          pq.NullTime
	ColumnUUID                 sql.NullString
}

type CompleteRepositoryBase struct {
	Table   string
	Columns []string
	DB      *sql.DB
	Log     LogFunc
}

func (r *CompleteRepositoryBase) InsertQuery(e *CompleteEntity, read bool) (string, []interface{}, error) {
	insert := NewComposer(33)
	columns := bytes.NewBuffer(nil)
	buf := bytes.NewBufferString("INSERT INTO ")
	buf.WriteString(r.Table)

	if e.ColumnBool.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnBool); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnBool)
		insert.Dirty = true
	}

	if e.ColumnBytea != nil {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnBytea); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnBytea)
		insert.Dirty = true
	}

	if e.ColumnCharacter0.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnCharacter0); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnCharacter0)
		insert.Dirty = true
	}

	if e.ColumnCharacter100.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnCharacter100); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnCharacter100)
		insert.Dirty = true
	}

	if e.ColumnDecimal.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnDecimal); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnDecimal)
		insert.Dirty = true
	}

	if e.ColumnDoubleArray0.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnDoubleArray0); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnDoubleArray0)
		insert.Dirty = true
	}

	if e.ColumnDoubleArray100.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnDoubleArray100); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnDoubleArray100)
		insert.Dirty = true
	}

	if e.ColumnInteger != nil {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnInteger); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnInteger)
		insert.Dirty = true
	}

	if e.ColumnIntegerArray0.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnIntegerArray0); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnIntegerArray0)
		insert.Dirty = true
	}

	if e.ColumnIntegerArray100.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnIntegerArray100); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnIntegerArray100)
		insert.Dirty = true
	}

	if e.ColumnIntegerBig.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnIntegerBig); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnIntegerBig)
		insert.Dirty = true
	}

	if e.ColumnIntegerBigArray0.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnIntegerBigArray0); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnIntegerBigArray0)
		insert.Dirty = true
	}

	if e.ColumnIntegerBigArray100.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnIntegerBigArray100); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnIntegerBigArray100)
		insert.Dirty = true
	}

	if e.ColumnIntegerSmall != nil {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnIntegerSmall); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnIntegerSmall)
		insert.Dirty = true
	}

	if e.ColumnIntegerSmallArray0.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnIntegerSmallArray0); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnIntegerSmallArray0)
		insert.Dirty = true
	}

	if e.ColumnIntegerSmallArray100.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnIntegerSmallArray100); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnIntegerSmallArray100)
		insert.Dirty = true
	}

	if e.ColumnJson != nil {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnJson); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnJson)
		insert.Dirty = true
	}

	if e.ColumnJsonNn != nil {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnJsonNn); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnJsonNn)
		insert.Dirty = true
	}

	if e.ColumnJsonNnD != nil {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnJsonNnD); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnJsonNnD)
		insert.Dirty = true
	}

	if e.ColumnJsonb != nil {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnJsonb); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnJsonb)
		insert.Dirty = true
	}

	if e.ColumnJsonbNn != nil {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnJsonbNn); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnJsonbNn)
		insert.Dirty = true
	}

	if e.ColumnJsonbNnD != nil {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnJsonbNnD); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnJsonbNnD)
		insert.Dirty = true
	}

	if e.ColumnNumeric.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnNumeric); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnNumeric)
		insert.Dirty = true
	}

	if e.ColumnReal != nil {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnReal); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnReal)
		insert.Dirty = true
	}

	if e.ColumnText.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnText); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnText)
		insert.Dirty = true
	}

	if e.ColumnTextArray0.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnTextArray0); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnTextArray0)
		insert.Dirty = true
	}

	if e.ColumnTextArray100.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnTextArray100); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnTextArray100)
		insert.Dirty = true
	}

	if e.ColumnTimestamp.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnTimestamp); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnTimestamp)
		insert.Dirty = true
	}

	if e.ColumnTimestamptz.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnTimestamptz); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnTimestamptz)
		insert.Dirty = true
	}

	if e.ColumnUUID.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnUUID); err != nil {
			return "", nil, err
		}
		if insert.Dirty {
			if _, err := insert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := insert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		insert.Add(e.ColumnUUID)
		insert.Dirty = true
	}

	if columns.Len() > 0 {
		buf.WriteString(" (")
		buf.ReadFrom(columns)
		buf.WriteString(") VALUES (")
		buf.ReadFrom(insert)
		buf.WriteString(") ")
		if read {
			buf.WriteString("RETURNING ")
			if len(r.Columns) > 0 {
				buf.WriteString(strings.Join(r.Columns, ", "))
			} else {
				buf.WriteString("column_bool, column_bytea, column_character_0, column_character_100, column_decimal, column_double_array_0, column_double_array_100, column_integer, column_integer_array_0, column_integer_array_100, column_integer_big, column_integer_big_array_0, column_integer_big_array_100, column_integer_small, column_integer_small_array_0, column_integer_small_array_100, column_json, column_json_nn, column_json_nn_d, column_jsonb, column_jsonb_nn, column_jsonb_nn_d, column_numeric, column_real, column_serial, column_serial_big, column_serial_small, column_text, column_text_array_0, column_text_array_100, column_timestamp, column_timestamptz, column_uuid")
			}
		}
	}
	return buf.String(), insert.Args(), nil
}

func (r *CompleteRepositoryBase) Insert(ctx context.Context, e *CompleteEntity) (*CompleteEntity, error) {
	query, args, err := r.InsertQuery(e, true)
	if err != nil {
		return nil, err
	}
	err = r.DB.QueryRowContext(ctx, query, args...).Scan(
		&e.ColumnBool,
		&e.ColumnBytea,
		&e.ColumnCharacter0,
		&e.ColumnCharacter100,
		&e.ColumnDecimal,
		&e.ColumnDoubleArray0,
		&e.ColumnDoubleArray100,
		&e.ColumnInteger,
		&e.ColumnIntegerArray0,
		&e.ColumnIntegerArray100,
		&e.ColumnIntegerBig,
		&e.ColumnIntegerBigArray0,
		&e.ColumnIntegerBigArray100,
		&e.ColumnIntegerSmall,
		&e.ColumnIntegerSmallArray0,
		&e.ColumnIntegerSmallArray100,
		&e.ColumnJson,
		&e.ColumnJsonNn,
		&e.ColumnJsonNnD,
		&e.ColumnJsonb,
		&e.ColumnJsonbNn,
		&e.ColumnJsonbNnD,
		&e.ColumnNumeric,
		&e.ColumnReal,
		&e.ColumnSerial,
		&e.ColumnSerialBig,
		&e.ColumnSerialSmall,
		&e.ColumnText,
		&e.ColumnTextArray0,
		&e.ColumnTextArray100,
		&e.ColumnTimestamp,
		&e.ColumnTimestamptz,
		&e.ColumnUUID,
	)
	if r.Log != nil {
		r.Log(err, TableComplete, "insert", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return e, nil
}

func CompleteCriteriaWhereClause(comp *Composer, c *CompleteCriteria, id int) error {
	if c.child == nil {
		return _CompleteCriteriaWhereClause(comp, c, id)
	}
	node := c
	sibling := false
	for {
		if !sibling {
			if node.child != nil {
				if node.parent != nil {
					comp.WriteString("(")
				}
				node = node.child
				continue
			} else {
				comp.Dirty = false
				comp.WriteString("(")
				if err := _CompleteCriteriaWhereClause(comp, node, id); err != nil {
					return err
				}
				comp.WriteString(")")
			}
		}
		if node.sibling != nil {
			sibling = false
			comp.WriteString(" ")
			comp.WriteString(node.parent.operator)
			comp.WriteString(" ")
			node = node.sibling
			continue
		}
		if node.parent != nil {
			sibling = true
			if node.parent.parent != nil {
				comp.WriteString(")")
			}
			node = node.parent
			continue
		}

		break
	}
	return nil
}

func _CompleteCriteriaWhereClause(comp *Composer, c *CompleteCriteria, id int) error {
	if c.ColumnBool.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnBool); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnBool)
		comp.Dirty = true
	}
	if c.ColumnBytea != nil {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnBytea); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnBytea)
		comp.Dirty = true
	}
	if c.ColumnCharacter0.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnCharacter0); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnCharacter0)
		comp.Dirty = true
	}
	if c.ColumnCharacter100.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnCharacter100); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnCharacter100)
		comp.Dirty = true
	}
	if c.ColumnDecimal.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnDecimal); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnDecimal)
		comp.Dirty = true
	}
	if c.ColumnDoubleArray0.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnDoubleArray0); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnDoubleArray0)
		comp.Dirty = true
	}
	if c.ColumnDoubleArray100.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnDoubleArray100); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnDoubleArray100)
		comp.Dirty = true
	}
	if c.ColumnInteger != nil {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnInteger); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnInteger)
		comp.Dirty = true
	}
	if c.ColumnIntegerArray0.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnIntegerArray0); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnIntegerArray0)
		comp.Dirty = true
	}
	if c.ColumnIntegerArray100.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnIntegerArray100); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnIntegerArray100)
		comp.Dirty = true
	}
	if c.ColumnIntegerBig.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnIntegerBig); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnIntegerBig)
		comp.Dirty = true
	}
	if c.ColumnIntegerBigArray0.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnIntegerBigArray0); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnIntegerBigArray0)
		comp.Dirty = true
	}
	if c.ColumnIntegerBigArray100.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnIntegerBigArray100); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnIntegerBigArray100)
		comp.Dirty = true
	}
	if c.ColumnIntegerSmall != nil {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnIntegerSmall); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnIntegerSmall)
		comp.Dirty = true
	}
	if c.ColumnIntegerSmallArray0.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnIntegerSmallArray0); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnIntegerSmallArray0)
		comp.Dirty = true
	}
	if c.ColumnIntegerSmallArray100.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnIntegerSmallArray100); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnIntegerSmallArray100)
		comp.Dirty = true
	}
	if c.ColumnJson != nil {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnJson); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnJson)
		comp.Dirty = true
	}
	if c.ColumnJsonNn != nil {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnJsonNn); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnJsonNn)
		comp.Dirty = true
	}
	if c.ColumnJsonNnD != nil {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnJsonNnD); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnJsonNnD)
		comp.Dirty = true
	}
	if c.ColumnJsonb != nil {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnJsonb); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnJsonb)
		comp.Dirty = true
	}
	if c.ColumnJsonbNn != nil {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnJsonbNn); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnJsonbNn)
		comp.Dirty = true
	}
	if c.ColumnJsonbNnD != nil {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnJsonbNnD); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnJsonbNnD)
		comp.Dirty = true
	}
	if c.ColumnNumeric.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnNumeric); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnNumeric)
		comp.Dirty = true
	}
	if c.ColumnReal != nil {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnReal); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnReal)
		comp.Dirty = true
	}
	if c.ColumnSerial != nil {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnSerial); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnSerial)
		comp.Dirty = true
	}
	// column_serial_big is an empty struct, ignore

	if c.ColumnSerialSmall != nil {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnSerialSmall); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnSerialSmall)
		comp.Dirty = true
	}
	if c.ColumnText.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnText); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnText)
		comp.Dirty = true
	}
	if c.ColumnTextArray0.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnTextArray0); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnTextArray0)
		comp.Dirty = true
	}
	if c.ColumnTextArray100.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnTextArray100); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnTextArray100)
		comp.Dirty = true
	}
	if c.ColumnTimestamp.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnTimestamp); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnTimestamp)
		comp.Dirty = true
	}
	if c.ColumnTimestamptz.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnTimestamptz); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnTimestamptz)
		comp.Dirty = true
	}
	if c.ColumnUUID.Valid {
		if comp.Dirty {
			comp.WriteString(" AND ")
		}
		if err := comp.WriteAlias(id); err != nil {
			return err
		}
		if _, err := comp.WriteString(TableCompleteColumnColumnUUID); err != nil {
			return err
		}
		if _, err := comp.WriteString("="); err != nil {
			return err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return err
		}
		comp.Add(c.ColumnUUID)
		comp.Dirty = true
	}
	return nil
}

func (r *CompleteRepositoryBase) FindQuery(fe *CompleteFindExpr) (string, []interface{}, error) {
	comp := NewComposer(33)
	buf := bytes.NewBufferString("SELECT ")
	if len(fe.Columns) == 0 {
		buf.WriteString("t0.column_bool, t0.column_bytea, t0.column_character_0, t0.column_character_100, t0.column_decimal, t0.column_double_array_0, t0.column_double_array_100, t0.column_integer, t0.column_integer_array_0, t0.column_integer_array_100, t0.column_integer_big, t0.column_integer_big_array_0, t0.column_integer_big_array_100, t0.column_integer_small, t0.column_integer_small_array_0, t0.column_integer_small_array_100, t0.column_json, t0.column_json_nn, t0.column_json_nn_d, t0.column_jsonb, t0.column_jsonb_nn, t0.column_jsonb_nn_d, t0.column_numeric, t0.column_real, t0.column_serial, t0.column_serial_big, t0.column_serial_small, t0.column_text, t0.column_text_array_0, t0.column_text_array_100, t0.column_timestamp, t0.column_timestamptz, t0.column_uuid")
	} else {
		buf.WriteString(strings.Join(fe.Columns, ", "))
	}
	buf.WriteString(" FROM ")
	buf.WriteString(r.Table)
	buf.WriteString(" AS t0")
	if comp.Dirty {
		buf.ReadFrom(comp)
		comp.Dirty = false
	}
	if fe.Where != nil {
		if err := CompleteCriteriaWhereClause(comp, fe.Where, 0); err != nil {
			return "", nil, err
		}
	}
	if comp.Dirty {
		if _, err := buf.WriteString(" WHERE "); err != nil {
			return "", nil, err
		}
		buf.ReadFrom(comp)
	}

	if len(fe.OrderBy) > 0 {
		i := 0
		for _, order := range fe.OrderBy {
			for _, columnName := range TableCompleteColumns {
				if order.Name == columnName {
					if i == 0 {
						comp.WriteString(" ORDER BY ")
					}
					if i > 0 {
						if _, err := comp.WriteString(", "); err != nil {
							return "", nil, err
						}
					}
					if _, err := comp.WriteString(order.Name); err != nil {
						return "", nil, err
					}
					if order.Descending {
						if _, err := comp.WriteString(" DESC"); err != nil {
							return "", nil, err
						}
					}
					i++
					break
				}
			}
		}
	}
	if fe.Offset > 0 {
		if _, err := comp.WriteString(" OFFSET "); err != nil {
			return "", nil, err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		if _, err := comp.WriteString(" "); err != nil {
			return "", nil, err
		}
		comp.Add(fe.Offset)
	}
	if fe.Limit > 0 {
		if _, err := comp.WriteString(" LIMIT "); err != nil {
			return "", nil, err
		}
		if err := comp.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		if _, err := comp.WriteString(" "); err != nil {
			return "", nil, err
		}
		comp.Add(fe.Limit)
	}

	buf.ReadFrom(comp)

	return buf.String(), comp.Args(), nil
}

func (r *CompleteRepositoryBase) Find(ctx context.Context, fe *CompleteFindExpr) ([]*CompleteEntity, error) {
	query, args, err := r.FindQuery(fe)
	if err != nil {
		return nil, err
	}
	rows, err := r.DB.QueryContext(ctx, query, args...)
	if r.Log != nil {
		r.Log(err, TableComplete, "find", query, args...)
	}
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var (
		entities []*CompleteEntity
		props    []interface{}
	)
	for rows.Next() {
		var ent CompleteEntity
		if props, err = ent.Props(); err != nil {
			return nil, err
		}
		err = rows.Scan(props...)
		if err != nil {
			return nil, err
		}

		entities = append(entities, &ent)
	}
	err = rows.Err()
	if r.Log != nil {
		r.Log(err, TableComplete, "find", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return entities, nil
}

func (r *CompleteRepositoryBase) FindIter(ctx context.Context, fe *CompleteFindExpr) (*CompleteIterator, error) {
	query, args, err := r.FindQuery(fe)
	if err != nil {
		return nil, err
	}
	rows, err := r.DB.QueryContext(ctx, query, args...)
	if r.Log != nil {
		r.Log(err, TableComplete, "find iter", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return &CompleteIterator{
		rows: rows,
		expr: fe,
		cols: fe.Columns,
	}, nil
}

func (r *CompleteRepositoryBase) UpsertQuery(e *CompleteEntity, p *CompletePatch, inf ...string) (string, []interface{}, error) {
	upsert := NewComposer(66)
	columns := bytes.NewBuffer(nil)
	buf := bytes.NewBufferString("INSERT INTO ")
	buf.WriteString(r.Table)

	if e.ColumnBool.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnBool); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnBool)
		upsert.Dirty = true
	}

	if e.ColumnBytea != nil {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnBytea); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnBytea)
		upsert.Dirty = true
	}

	if e.ColumnCharacter0.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnCharacter0); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnCharacter0)
		upsert.Dirty = true
	}

	if e.ColumnCharacter100.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnCharacter100); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnCharacter100)
		upsert.Dirty = true
	}

	if e.ColumnDecimal.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnDecimal); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnDecimal)
		upsert.Dirty = true
	}

	if e.ColumnDoubleArray0.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnDoubleArray0); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnDoubleArray0)
		upsert.Dirty = true
	}

	if e.ColumnDoubleArray100.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnDoubleArray100); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnDoubleArray100)
		upsert.Dirty = true
	}

	if e.ColumnInteger != nil {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnInteger); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnInteger)
		upsert.Dirty = true
	}

	if e.ColumnIntegerArray0.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnIntegerArray0); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnIntegerArray0)
		upsert.Dirty = true
	}

	if e.ColumnIntegerArray100.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnIntegerArray100); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnIntegerArray100)
		upsert.Dirty = true
	}

	if e.ColumnIntegerBig.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnIntegerBig); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnIntegerBig)
		upsert.Dirty = true
	}

	if e.ColumnIntegerBigArray0.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnIntegerBigArray0); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnIntegerBigArray0)
		upsert.Dirty = true
	}

	if e.ColumnIntegerBigArray100.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnIntegerBigArray100); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnIntegerBigArray100)
		upsert.Dirty = true
	}

	if e.ColumnIntegerSmall != nil {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnIntegerSmall); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnIntegerSmall)
		upsert.Dirty = true
	}

	if e.ColumnIntegerSmallArray0.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnIntegerSmallArray0); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnIntegerSmallArray0)
		upsert.Dirty = true
	}

	if e.ColumnIntegerSmallArray100.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnIntegerSmallArray100); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnIntegerSmallArray100)
		upsert.Dirty = true
	}

	if e.ColumnJson != nil {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnJson); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnJson)
		upsert.Dirty = true
	}

	if e.ColumnJsonNn != nil {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnJsonNn); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnJsonNn)
		upsert.Dirty = true
	}

	if e.ColumnJsonNnD != nil {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnJsonNnD); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnJsonNnD)
		upsert.Dirty = true
	}

	if e.ColumnJsonb != nil {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnJsonb); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnJsonb)
		upsert.Dirty = true
	}

	if e.ColumnJsonbNn != nil {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnJsonbNn); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnJsonbNn)
		upsert.Dirty = true
	}

	if e.ColumnJsonbNnD != nil {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnJsonbNnD); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnJsonbNnD)
		upsert.Dirty = true
	}

	if e.ColumnNumeric.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnNumeric); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnNumeric)
		upsert.Dirty = true
	}

	if e.ColumnReal != nil {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnReal); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnReal)
		upsert.Dirty = true
	}

	if e.ColumnText.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnText); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnText)
		upsert.Dirty = true
	}

	if e.ColumnTextArray0.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnTextArray0); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnTextArray0)
		upsert.Dirty = true
	}

	if e.ColumnTextArray100.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnTextArray100); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnTextArray100)
		upsert.Dirty = true
	}

	if e.ColumnTimestamp.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnTimestamp); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnTimestamp)
		upsert.Dirty = true
	}

	if e.ColumnTimestamptz.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnTimestamptz); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnTimestamptz)
		upsert.Dirty = true
	}

	if e.ColumnUUID.Valid {
		if columns.Len() > 0 {
			if _, err := columns.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if _, err := columns.WriteString(TableCompleteColumnColumnUUID); err != nil {
			return "", nil, err
		}
		if upsert.Dirty {
			if _, err := upsert.WriteString(", "); err != nil {
				return "", nil, err
			}
		}
		if err := upsert.WritePlaceholder(); err != nil {
			return "", nil, err
		}
		upsert.Add(e.ColumnUUID)
		upsert.Dirty = true
	}

	if upsert.Dirty {
		buf.WriteString(" (")
		buf.ReadFrom(columns)
		buf.WriteString(") VALUES (")
		buf.ReadFrom(upsert)
		buf.WriteString(")")
	}
	buf.WriteString(" ON CONFLICT ")
	if len(inf) > 0 {
		upsert.Dirty = false
		if p.ColumnBool.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnBool); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnBool)
			upsert.Dirty = true

		}
		if p.ColumnBytea != nil {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnBytea); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnBytea)
			upsert.Dirty = true

		}
		if p.ColumnCharacter0.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnCharacter0); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnCharacter0)
			upsert.Dirty = true

		}
		if p.ColumnCharacter100.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnCharacter100); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnCharacter100)
			upsert.Dirty = true

		}
		if p.ColumnDecimal.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnDecimal); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnDecimal)
			upsert.Dirty = true

		}
		if p.ColumnDoubleArray0.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnDoubleArray0); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnDoubleArray0)
			upsert.Dirty = true

		}
		if p.ColumnDoubleArray100.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnDoubleArray100); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnDoubleArray100)
			upsert.Dirty = true

		}
		if p.ColumnInteger != nil {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnInteger); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnInteger)
			upsert.Dirty = true

		}
		if p.ColumnIntegerArray0.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnIntegerArray0); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnIntegerArray0)
			upsert.Dirty = true

		}
		if p.ColumnIntegerArray100.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnIntegerArray100); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnIntegerArray100)
			upsert.Dirty = true

		}
		if p.ColumnIntegerBig.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnIntegerBig); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnIntegerBig)
			upsert.Dirty = true

		}
		if p.ColumnIntegerBigArray0.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnIntegerBigArray0); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnIntegerBigArray0)
			upsert.Dirty = true

		}
		if p.ColumnIntegerBigArray100.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnIntegerBigArray100); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnIntegerBigArray100)
			upsert.Dirty = true

		}
		if p.ColumnIntegerSmall != nil {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnIntegerSmall); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnIntegerSmall)
			upsert.Dirty = true

		}
		if p.ColumnIntegerSmallArray0.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnIntegerSmallArray0); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnIntegerSmallArray0)
			upsert.Dirty = true

		}
		if p.ColumnIntegerSmallArray100.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnIntegerSmallArray100); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnIntegerSmallArray100)
			upsert.Dirty = true

		}
		if p.ColumnJson != nil {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnJson); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnJson)
			upsert.Dirty = true

		}
		if p.ColumnJsonNn != nil {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnJsonNn); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnJsonNn)
			upsert.Dirty = true

		}
		if p.ColumnJsonNnD != nil {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnJsonNnD); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnJsonNnD)
			upsert.Dirty = true

		}
		if p.ColumnJsonb != nil {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnJsonb); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnJsonb)
			upsert.Dirty = true

		}
		if p.ColumnJsonbNn != nil {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnJsonbNn); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnJsonbNn)
			upsert.Dirty = true

		}
		if p.ColumnJsonbNnD != nil {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnJsonbNnD); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnJsonbNnD)
			upsert.Dirty = true

		}
		if p.ColumnNumeric.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnNumeric); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnNumeric)
			upsert.Dirty = true

		}
		if p.ColumnReal != nil {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnReal); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnReal)
			upsert.Dirty = true

		}
		if p.ColumnSerial != nil {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnSerial); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnSerial)
			upsert.Dirty = true

		}
		if p.ColumnSerialBig.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnSerialBig); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnSerialBig)
			upsert.Dirty = true

		}
		if p.ColumnSerialSmall != nil {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnSerialSmall); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnSerialSmall)
			upsert.Dirty = true

		}
		if p.ColumnText.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnText); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnText)
			upsert.Dirty = true

		}
		if p.ColumnTextArray0.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnTextArray0); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnTextArray0)
			upsert.Dirty = true

		}
		if p.ColumnTextArray100.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnTextArray100); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnTextArray100)
			upsert.Dirty = true

		}
		if p.ColumnTimestamp.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnTimestamp); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnTimestamp)
			upsert.Dirty = true

		}
		if p.ColumnTimestamptz.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnTimestamptz); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnTimestamptz)
			upsert.Dirty = true

		}
		if p.ColumnUUID.Valid {
			if upsert.Dirty {
				if _, err := upsert.WriteString(", "); err != nil {
					return "", nil, err
				}
			}
			if _, err := upsert.WriteString(TableCompleteColumnColumnUUID); err != nil {
				return "", nil, err
			}
			if _, err := upsert.WriteString("="); err != nil {
				return "", nil, err
			}
			if err := upsert.WritePlaceholder(); err != nil {
				return "", nil, err
			}
			upsert.Add(p.ColumnUUID)
			upsert.Dirty = true

		}
	}
	if len(inf) > 0 && upsert.Dirty {
		buf.WriteString("(")
		for j, i := range inf {
			if j != 0 {
				buf.WriteString(", ")
			}
			buf.WriteString(i)
		}
		buf.WriteString(")")
		buf.WriteString(" DO UPDATE SET ")
		buf.ReadFrom(upsert)
	} else {
		buf.WriteString(" DO NOTHING ")
	}
	if upsert.Dirty {
		buf.WriteString(" RETURNING ")
		if len(r.Columns) > 0 {
			buf.WriteString(strings.Join(r.Columns, ", "))
		} else {
			buf.WriteString("column_bool, column_bytea, column_character_0, column_character_100, column_decimal, column_double_array_0, column_double_array_100, column_integer, column_integer_array_0, column_integer_array_100, column_integer_big, column_integer_big_array_0, column_integer_big_array_100, column_integer_small, column_integer_small_array_0, column_integer_small_array_100, column_json, column_json_nn, column_json_nn_d, column_jsonb, column_jsonb_nn, column_jsonb_nn_d, column_numeric, column_real, column_serial, column_serial_big, column_serial_small, column_text, column_text_array_0, column_text_array_100, column_timestamp, column_timestamptz, column_uuid")
		}
	}
	return buf.String(), upsert.Args(), nil
}

func (r *CompleteRepositoryBase) Upsert(ctx context.Context, e *CompleteEntity, p *CompletePatch, inf ...string) (*CompleteEntity, error) {
	query, args, err := r.UpsertQuery(e, p, inf...)
	if err != nil {
		return nil, err
	}
	err = r.DB.QueryRowContext(ctx, query, args...).Scan(
		&e.ColumnBool,
		&e.ColumnBytea,
		&e.ColumnCharacter0,
		&e.ColumnCharacter100,
		&e.ColumnDecimal,
		&e.ColumnDoubleArray0,
		&e.ColumnDoubleArray100,
		&e.ColumnInteger,
		&e.ColumnIntegerArray0,
		&e.ColumnIntegerArray100,
		&e.ColumnIntegerBig,
		&e.ColumnIntegerBigArray0,
		&e.ColumnIntegerBigArray100,
		&e.ColumnIntegerSmall,
		&e.ColumnIntegerSmallArray0,
		&e.ColumnIntegerSmallArray100,
		&e.ColumnJson,
		&e.ColumnJsonNn,
		&e.ColumnJsonNnD,
		&e.ColumnJsonb,
		&e.ColumnJsonbNn,
		&e.ColumnJsonbNnD,
		&e.ColumnNumeric,
		&e.ColumnReal,
		&e.ColumnSerial,
		&e.ColumnSerialBig,
		&e.ColumnSerialSmall,
		&e.ColumnText,
		&e.ColumnTextArray0,
		&e.ColumnTextArray100,
		&e.ColumnTimestamp,
		&e.ColumnTimestamptz,
		&e.ColumnUUID,
	)
	if r.Log != nil {
		r.Log(err, TableComplete, "upsert", query, args...)
	}
	if err != nil {
		return nil, err
	}
	return e, nil
}

func (r *CompleteRepositoryBase) Count(ctx context.Context, c *CompleteCountExpr) (int64, error) {
	query, args, err := r.FindQuery(&CompleteFindExpr{
		Where:   c.Where,
		Columns: []string{"COUNT(*)"},
	})
	if err != nil {
		return 0, err
	}
	var count int64
	err = r.DB.QueryRowContext(ctx, query, args...).Scan(&count)
	if r.Log != nil {
		r.Log(err, TableComplete, "count", query, args...)
	}
	if err != nil {
		return 0, err
	}
	return count, nil
}

const (
	JoinInner = iota
	JoinLeft
	JoinRight
	JoinCross
	JoinDoNot
)

type JoinType int

func (jt JoinType) String() string {
	switch jt {

	case JoinInner:
		return "INNER JOIN"
	case JoinLeft:
		return "LEFT JOIN"
	case JoinRight:
		return "RIGHT JOIN"
	case JoinCross:
		return "CROSS JOIN"
	default:
		return ""
	}
}

// Actionable returns true if JoinType is one of the known type except JoinDoNot.
func (jt JoinType) Actionable() bool {
	switch jt {
	case JoinInner, JoinLeft, JoinRight, JoinCross:
		return true
	default:
		return false
	}
}

// ErrorConstraint returns the error constraint of err if it was produced by the pq library.
// Otherwise, it returns empty string.
func ErrorConstraint(err error) string {
	if err == nil {
		return ""
	}
	if pqerr, ok := err.(*pq.Error); ok {
		return pqerr.Constraint
	}

	return ""
}

type RowOrder struct {
	Name       string
	Descending bool
}

type NullInt64Array struct {
	pq.Int64Array
	Valid bool
}

func (n *NullInt64Array) Scan(value interface{}) error {
	if value == nil {
		n.Int64Array, n.Valid = nil, false
		return nil
	}
	n.Valid = true
	return n.Int64Array.Scan(value)
}

type NullFloat64Array struct {
	pq.Float64Array
	Valid bool
}

func (n *NullFloat64Array) Scan(value interface{}) error {
	if value == nil {
		n.Float64Array, n.Valid = nil, false
		return nil
	}
	n.Valid = true
	return n.Float64Array.Scan(value)
}

type NullBoolArray struct {
	pq.BoolArray
	Valid bool
}

func (n *NullBoolArray) Scan(value interface{}) error {
	if value == nil {
		n.BoolArray, n.Valid = nil, false
		return nil
	}
	n.Valid = true
	return n.BoolArray.Scan(value)
}

type NullStringArray struct {
	pq.StringArray
	Valid bool
}

func (n *NullStringArray) Scan(value interface{}) error {
	if value == nil {
		n.StringArray, n.Valid = nil, false
		return nil
	}
	n.Valid = true
	return n.StringArray.Scan(value)
}

type NullByteaArray struct {
	pq.ByteaArray
	Valid bool
}

func (n *NullByteaArray) Scan(value interface{}) error {
	if value == nil {
		n.ByteaArray, n.Valid = nil, false
		return nil
	}
	n.Valid = true
	return n.ByteaArray.Scan(value)
}

const (
	jsonArraySeparator     = ","
	jsonArrayBeginningChar = "["
	jsonArrayEndChar       = "]"
)

// JSONArrayInt64 is a slice of int64s that implements necessary interfaces.
type JSONArrayInt64 []int64

// Scan satisfy sql.Scanner interface.
func (a *JSONArrayInt64) Scan(src interface{}) error {
	if src == nil {
		if a == nil {
			*a = make(JSONArrayInt64, 0)
		}
		return nil
	}

	var tmp []string
	var srcs string

	switch t := src.(type) {
	case []byte:
		srcs = string(t)
	case string:
		srcs = t
	default:
		return fmt.Errorf("expected slice of bytes or string as a source argument in Scan, not %T", src)
	}

	l := len(srcs)

	if l < 2 {
		return fmt.Errorf("expected to get source argument in format '[1,2,...,N]', but got %s", srcs)
	}

	if l == 2 {
		*a = make(JSONArrayInt64, 0)
		return nil
	}

	if string(srcs[0]) != jsonArrayBeginningChar || string(srcs[l-1]) != jsonArrayEndChar {
		return fmt.Errorf("expected to get source argument in format '[1,2,...,N]', but got %s", srcs)
	}

	tmp = strings.Split(string(srcs[1:l-1]), jsonArraySeparator)
	*a = make(JSONArrayInt64, 0, len(tmp))
	for i, v := range tmp {
		j, err := strconv.ParseInt(v, 10, 64)
		if err != nil {
			return fmt.Errorf("expected to get source argument in format '[1,2,...,N]', but got %s at index %d", v, i)
		}

		*a = append(*a, j)
	}

	return nil
}

// Value satisfy driver.Valuer interface.
func (a JSONArrayInt64) Value() (driver.Value, error) {
	var (
		buffer bytes.Buffer
		err    error
	)

	if _, err = buffer.WriteString(jsonArrayBeginningChar); err != nil {
		return nil, err
	}

	for i, v := range a {
		if i > 0 {
			if _, err := buffer.WriteString(jsonArraySeparator); err != nil {
				return nil, err
			}
		}
		if _, err := buffer.WriteString(strconv.FormatInt(v, 10)); err != nil {
			return nil, err
		}
	}

	if _, err = buffer.WriteString(jsonArrayEndChar); err != nil {
		return nil, err
	}

	return buffer.Bytes(), nil
}

// JSONArrayString is a slice of strings that implements necessary interfaces.
type JSONArrayString []string

// Scan satisfy sql.Scanner interface.
func (a *JSONArrayString) Scan(src interface{}) error {
	if src == nil {
		if a == nil {
			*a = make(JSONArrayString, 0)
		}
		return nil
	}

	switch t := src.(type) {
	case []byte:
		return json.Unmarshal(t, a)
	default:
		return fmt.Errorf("expected slice of bytes or string as a source argument in Scan, not %T", src)
	}
}

// Value satisfy driver.Valuer interface.
func (a JSONArrayString) Value() (driver.Value, error) {
	return json.Marshal(a)
}

// JSONArrayFloat64 is a slice of int64s that implements necessary interfaces.
type JSONArrayFloat64 []float64

// Scan satisfy sql.Scanner interface.
func (a *JSONArrayFloat64) Scan(src interface{}) error {
	if src == nil {
		if a == nil {
			*a = make(JSONArrayFloat64, 0)
		}
		return nil
	}

	var tmp []string
	var srcs string

	switch t := src.(type) {
	case []byte:
		srcs = string(t)
	case string:
		srcs = t
	default:
		return fmt.Errorf("expected slice of bytes or string as a source argument in Scan, not %T", src)
	}

	l := len(srcs)

	if l < 2 {
		return fmt.Errorf("expected to get source argument in format '[1.3,2.4,...,N.M]', but got %s", srcs)
	}

	if l == 2 {
		*a = make(JSONArrayFloat64, 0)
		return nil
	}

	if string(srcs[0]) != jsonArrayBeginningChar || string(srcs[l-1]) != jsonArrayEndChar {
		return fmt.Errorf("expected to get source argument in format '[1.3,2.4,...,N.M]', but got %s", srcs)
	}

	tmp = strings.Split(string(srcs[1:l-1]), jsonArraySeparator)
	*a = make(JSONArrayFloat64, 0, len(tmp))
	for i, v := range tmp {
		j, err := strconv.ParseFloat(v, 64)
		if err != nil {
			return fmt.Errorf("expected to get source argument in format '[1.3,2.4,...,N.M]', but got %s at index %d", v, i)
		}

		*a = append(*a, j)
	}

	return nil
}

// Value satisfy driver.Valuer interface.
func (a JSONArrayFloat64) Value() (driver.Value, error) {
	var (
		buffer bytes.Buffer
		err    error
	)

	if _, err = buffer.WriteString(jsonArrayBeginningChar); err != nil {
		return nil, err
	}

	for i, v := range a {
		if i > 0 {
			if _, err := buffer.WriteString(jsonArraySeparator); err != nil {
				return nil, err
			}
		}
		if _, err := buffer.WriteString(strconv.FormatFloat(v, 'f', -1, 64)); err != nil {
			return nil, err
		}
	}

	if _, err = buffer.WriteString(jsonArrayEndChar); err != nil {
		return nil, err
	}

	return buffer.Bytes(), nil
}

var (
	// Space is a shorthand composition option that holds space.
	Space = &CompositionOpts{
		Joint: " ",
	}
	// And is a shorthand composition option that holds AND operator.
	And = &CompositionOpts{
		Joint: " AND ",
	}
	// Or is a shorthand composition option that holds OR operator.
	Or = &CompositionOpts{
		Joint: " OR ",
	}
	// Comma is a shorthand composition option that holds comma.
	Comma = &CompositionOpts{
		Joint: ", ",
	}
)

// CompositionOpts is a container for modification that can be applied.
type CompositionOpts struct {
	Joint                           string
	PlaceholderFuncs, SelectorFuncs []string
	PlaceholderCast, SelectorCast   string
	IsJSON                          bool
	IsDynamic                       bool
}

// CompositionWriter is a simple wrapper for WriteComposition function.
type CompositionWriter interface {
	// WriteComposition is a function that allow custom struct type to be used as a part of criteria.
	// It gives possibility to write custom query based on object that implements this interface.
	WriteComposition(string, *Composer, *CompositionOpts) error
}

// Composer holds buffer, arguments and placeholders count.
// In combination with external buffet can be also used to also generate sub-queries.
// To do that simply write buffer to the parent buffer, composer will hold all arguments and remember number of last placeholder.
type Composer struct {
	buf     bytes.Buffer
	args    []interface{}
	counter int
	Dirty   bool
}

// NewComposer allocates new Composer with inner slice of arguments of given size.
func NewComposer(size int64) *Composer {
	return &Composer{
		counter: 1,
		args:    make([]interface{}, 0, size),
	}
}

// WriteString appends the contents of s to the query buffer, growing the buffer as
// needed. The return value n is the length of s; err is always nil. If the
// buffer becomes too large, WriteString will panic with bytes ErrTooLarge.
func (c *Composer) WriteString(s string) (int, error) {
	return c.buf.WriteString(s)
}

// Write implements io Writer interface.
func (c *Composer) Write(b []byte) (int, error) {
	return c.buf.Write(b)
}

// Read implements io Reader interface.
func (c *Composer) Read(b []byte) (int, error) {
	return c.buf.Read(b)
}

// ResetBuf resets internal buffer.
func (c *Composer) ResetBuf() {
	c.buf.Reset()
}

// String implements fmt Stringer interface.
func (c *Composer) String() string {
	return c.buf.String()
}

// WritePlaceholder writes appropriate placeholder to the query buffer based on current state of the composer.
func (c *Composer) WritePlaceholder() error {
	if _, err := c.buf.WriteString("$"); err != nil {
		return err
	}
	if _, err := c.buf.WriteString(strconv.Itoa(c.counter)); err != nil {
		return err
	}

	c.counter++
	return nil
}

func (c *Composer) WriteAlias(i int) error {
	if i < 0 {
		return nil
	}
	if _, err := c.buf.WriteString("t"); err != nil {
		return err
	}
	if _, err := c.buf.WriteString(strconv.Itoa(i)); err != nil {
		return err
	}
	if _, err := c.buf.WriteString("."); err != nil {
		return err
	}
	return nil
}

// Len returns number of arguments.
func (c *Composer) Len() int {
	return c.counter
}

// Add appends list with new element.
func (c *Composer) Add(arg interface{}) {
	c.args = append(c.args, arg)
}

// Args returns all arguments stored as a slice.
func (c *Composer) Args() []interface{} {
	return c.args
}

/// SQL ...
const SQL = `
-- do not modify, generated by pqt

CREATE SCHEMA IF NOT EXISTS example; 

CREATE OR REPLACE FUNCTION multiply(x BIGINT, y BIGINT) RETURNS BIGINT
	AS 'SELECT x * y'
	LANGUAGE SQL
	VOLATILE;

CREATE TABLE IF NOT EXISTS example.category (
	content TEXT NOT NULL,
	created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
	id BIGSERIAL,
	name TEXT NOT NULL,
	parent_id BIGINT,
	updated_at TIMESTAMPTZ,

	CONSTRAINT "example.category_id_pkey" PRIMARY KEY (id),
	CONSTRAINT "example.category_parent_id_fkey" FOREIGN KEY (parent_id) REFERENCES example.category (id)
);
CREATE INDEX IF NOT EXISTS "example.category_name_idx" ON example.category (name);

CREATE TABLE IF NOT EXISTS example.package (
	break TEXT,
	category_id BIGINT,
	created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
	id BIGSERIAL,
	updated_at TIMESTAMPTZ,

	CONSTRAINT "example.package_id_pkey" PRIMARY KEY (id),
	CONSTRAINT "example.package_category_id_fkey" FOREIGN KEY (category_id) REFERENCES example.category (id)
);

CREATE TABLE IF NOT EXISTS example.news (
	content TEXT NOT NULL,
	continue BOOL DEFAULT false NOT NULL,
	created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
	day DATE,
	id BIGSERIAL,
	lead TEXT,
	meta_data JSONB,
	score NUMERIC(20,8) DEFAULT 0 NOT NULL,
	title TEXT NOT NULL,
	updated_at TIMESTAMPTZ,
	version BIGINT NOT NULL,
	views_distribution DOUBLE PRECISION[168],

	CONSTRAINT "example.news_id_pkey" PRIMARY KEY (id),
	CONSTRAINT "example.news_title_key" UNIQUE (title),
	CONSTRAINT "example.news_title_lead_key" UNIQUE (title, lead)
);

CREATE TABLE IF NOT EXISTS example.comment (
	content TEXT NOT NULL,
	created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
	id BIGSERIAL,
	news_id BIGINT NOT NULL,
	news_title TEXT NOT NULL,
	updated_at TIMESTAMPTZ,

	CONSTRAINT "example.comment_news_title_fkey" FOREIGN KEY (news_title) REFERENCES example.news (title),
	CONSTRAINT "example.comment_news_id_fkey" FOREIGN KEY (news_id) REFERENCES example.news (id)
);
CREATE INDEX IF NOT EXISTS "example.comment_news_title_idx" ON example.comment (news_title);

CREATE TABLE IF NOT EXISTS example.complete (
	column_bool BOOL,
	column_bytea BYTEA,
	column_character_0 CHARACTER[0],
	column_character_100 CHARACTER[100],
	column_decimal DECIMAL(20,8),
	column_double_array_0 DOUBLE PRECISION[],
	column_double_array_100 DOUBLE PRECISION[100],
	column_integer INTEGER,
	column_integer_array_0 INTEGER[],
	column_integer_array_100 INTEGER[100],
	column_integer_big BIGINT,
	column_integer_big_array_0 BIGINT[],
	column_integer_big_array_100 BIGINT[100],
	column_integer_small SMALLINT,
	column_integer_small_array_0 SMALLINT[],
	column_integer_small_array_100 SMALLINT[100],
	column_json JSON,
	column_json_nn JSON NOT NULL,
	column_json_nn_d JSON DEFAULT '{"field": 1}' NOT NULL,
	column_jsonb JSONB,
	column_jsonb_nn JSONB NOT NULL,
	column_jsonb_nn_d JSONB DEFAULT '{"field": 1}' NOT NULL,
	column_numeric NUMERIC(20,8),
	column_real REAL,
	column_serial SERIAL,
	column_serial_big BIGSERIAL,
	column_serial_small SMALLSERIAL,
	column_text TEXT,
	column_text_array_0 TEXT[],
	column_text_array_100 TEXT[100],
	column_timestamp TIMESTAMP,
	column_timestamptz TIMESTAMPTZ,
	column_uuid UUID
);

`
